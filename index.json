[{"categories":["documentation"],"contents":" Introduction   The ```sysstat``` package contains various utilities, common to many commercial Unixes, to monitor system performance and usage activity. http://sebastien.godard.pagesperso-orange.fr/  sysstat is a standard package which comes with Slackware distribution and almost any other distribution out there. Its a very useful tool to analize and monitor linux performance.\nWe are going to build a simple status page which will display performance metrics about the linux systems it runs on, including usage of:\n CPU Memory Network Disk  And also process based statistics such system load and process queue.\nWe want something simple, but sysstat tools are powerfull enough to build much more complex systems.\nInstall sysstat package sysstat package comes preinstalled in a full installation of Slackware, but if you\u0026rsquo;re using a custom package setup, please check you have sysstat and lm_sensors packages.\nMonitoring We want to calculate statistics in 10 minute periods with one measurement each minute. So we use the sa1 tool to record all collectable data in periods of 600 seconds with collection every 60 seconds. Also we want to repeat this process constantly so we create a cron job to automate the execution.\nThis tool will save in the file `/var/log/sa/saDD the data collected and will change DD accordinly to the they of the month.\n# monitoring 0,10,20,30,40,50 * * * * /usr/lib64/sa/sa1 -S XALL 600 60 Then we want to generate some graphics to read the data and store them in a location accesible by our webserver. We want to update our status page as soon as the data has been collected. Using the sadf tools we generate an SVG image containg all the graphs we need:\n CPU: -u Memory: -r Network: -n DEV Disk: -d System Load: -p Process queue: -q  So we add another cronjob, to execute after the other one. Also we save the results of the svg generation in the file /var/www/sar/stats.svg. This directory needs to be configured in our webserverto make it available externally. It is also possible to download the file using ssh to view it locally if we do not have a web service in the system.\n1,11,21,31,41,51 * * * * /usr/bin/sadf -g -- -u -p -q -r -d -n DEV \u0026gt; /var/www/sar/stats.svg The status page In order to view the generated SVG easily in a browser of mobile, we generate an HTML template as follows:\n\u0026lt;!doctype html\u0026gt; \u0026lt;html class=\u0026#34;no-js\u0026#34; lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;x-ua-compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Linux Sysstat Page\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, shrink-to-fit=no\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .svg-container { display: inline-block; vertical-align: middle; } .svg-content { display: inline-block; top: 0; left: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!--[if lte IE 9]\u0026gt; \u0026lt;p class=\u0026#34;browserupgrade\u0026#34;\u0026gt;You are using an \u0026lt;strong\u0026gt;outdated\u0026lt;/strong\u0026gt; browser. Please \u0026lt;a href=\u0026#34;https://browsehappy.com/\u0026#34;\u0026gt;upgrade your browser\u0026lt;/a\u0026gt; t o improve your experience and security.\u0026lt;/p\u0026gt; \u0026lt;![endif]--\u0026gt; \u0026lt;div class=\u0026#34;svg-container\u0026#34;\u0026gt; \u0026lt;object type=\u0026#34;image/svg+xml\u0026#34; data=\u0026#34;stats.svg\u0026#34; width=\u0026#34;1024px\u0026#34; height=\u0026#34;9000px\u0026#34; class=\u0026#34;svg-content\u0026#34;\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  And save it as /var/www/sar/index.html.\nThe size specified in the SVG object was generated taking into account our output from the sadf tool. It might change if your options change, so update it accordingly.\nResources  Demo Home page systsat tutorial  ","summary":"Introduction   The ```sysstat``` package contains various utilities, common to many commercial Unixes, to monitor system performance and usage activity. http://sebastien.godard.pagesperso-orange.fr/  sysstat is a standard package which comes with Slackware distribution and almost any other distribution out there. Its a very useful tool to analize and monitor linux performance.\nWe are going to build a simple status page which will display performance metrics about the linux systems it runs on, including usage of:","tags":["sysstat","howto"],"title":"Sysstat: an easy status page","url":"/web/posts/statuspage/"},{"categories":["documentation"],"contents":" Introduction   PostgREST is a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations. Using PostgREST is an alternative to manual CRUD programming. Custom API servers suffer problems. Writing business logic often duplicates, ignores or hobbles database structure. Object-relational mapping is a leaky abstraction leading to slow imperative code. The PostgREST philosophy establishes a single declarative source of truth: the data itself. https://postgrest.org/en/v5.0/intro.html  Our aim is to build and experiment with applications using an HTTP based back-end. These applications can use a lot of languages and environments: shell scripts, Javascript, etc.\nBuilding a package for Slackware PostgREST is written in the Haskell programming language, so to build the software we need a Haskell compiler installed into our build system. We can install the Glasgow Haskell Compiler from the SlackBuild repository. The official build instructions are basically to execute the command:\n# stack build --install-ghc --copy-bins --local-bin-path /usr/local/bin With this information, we can build our own SlackBuild script. Look into our repository to see all the files.\nBuild the PostgREST package executing the postgrest.SlackBuild script. It will generate the package into /tmp.\nOnce you have the package, we need to install it into the server.\nBefore setting up This package requires a working PostgreSQL database, configured with user access, tables, etc. The service requires planning carefully the database schemas, permissions and functions to work.\nTry to set up first an SQL program to build your database before setting up PostgREST. Also, follow the tutorials and the documentation in their website.\nWe had problems with schema isolation. We learned that we need to set up the search_path per function.\nIt is also advisable to split the internal procedures, and the external ones, so only the API only exposes what it is really neeed and nothing more.\nSetting PostgREST up Before starting, PostREST needs a configuration file describing the environment. The package expects the configuration file to be /opt/postgrest/etc/postgrest.conf. The configuration file documentation details how to set up PostgREST. It will neeed the PostgreSQL database URI, the database schema and the database anonymous role.\nTo get things right, it is advisable to follow the getting started (tutorial)[https://postgrest.org/en/v5.0/tutorials/tut0.html].\nResources  Home page Github repository StackOverflow Gitter  ","summary":"Introduction   PostgREST is a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations. Using PostgREST is an alternative to manual CRUD programming. Custom API servers suffer problems. Writing business logic often duplicates, ignores or hobbles database structure. Object-relational mapping is a leaky abstraction leading to slow imperative code. The PostgREST philosophy establishes a single declarative source of truth: the data itself.","tags":["postgrest","howto"],"title":"PostgREST: BAAS for PostgreSQL databases","url":"/web/posts/postgrest/"},{"categories":["documentation"],"contents":"From it\u0026rsquo;s Github page:\nJitsi Meet is an open-source (Apache) WebRTC JavaScript application that uses Jitsi Videobridge to provide high quality, secure and scalable video conferences. You can see Jitsi Meet in action here at the session #482 of the VoIP Users Conference.\nThe Jitsi Meet client runs in your browser, without the need for installing anything on your computer. You can also try it out yourself at https://meet.jit.si .\nJitsi Meet allows for very efficient collaboration. It allows users to stream their desktop or only some windows. It also supports shared document editing with Etherpad.\nIntroduction We want to offer a secure video conference service for our company.We selected jitsi-meet as our video conference platform because it meets all our requirements.\nAs soon as we check their documentation, it’s clear they only support Ubuntu and Debian Linux distributions. But they also provide hints to do a manual install of their software.\nIn this document we will set up and install a single instance of this platform using Slackware 64 bits Current.\nService architecture The general architecture of the service as per their documentation is:\n+ + | | | | v | 443 | +-------+ | | | | | NginX | | | | | +--+-+--+ | | | | +------------+ | | +--------------+ | | | | | | | | | jitsi-meet +\u0026lt;---+ +---\u0026gt;+ prosody/xmpp | | | |files 5280 | | | +------------+ +--------------+ v 5222,5347^ ^5347 4443 +--------+ | | +-------------+ | | | | | | | jicofo +----^ ^----+ videobridge | | | | | +--------+ +-------------+ jitsi-meet basic requirements are:\n A web server with a valid SSL certificate,\n The Prosody Jabber service, with their JWT plug-in\n The Jitsi VideoBridge service\n The Jitsi Conference Focus (jicofo) service\n The Java platform 8\n The Lua platform 5\n  Also we are going to need:\n Four different secrets for components communication\n A prosody user and group\n  Software packages We have identified what software we need to install in our server to make jitsi-meet work and created SlackBuild scripts for them. You can check our source code repository or our binary packages at slackware.es.\nWe also used packages from slackbuilds.org, like the prosody server package, and also we used those scripts as a base for our own.\n├── caddy-0.11-x86_64-1_es.tgz ├── jdk-8u181-x86_64-1.txz ├── jitsi │ ├── jicofo-1.1-x86_64-1_es.tgz │ ├── jitsi-meet-1.1-x86_64-1_es.tgz │ ├── jitsi-meet-token-1.1-x86_64-1_es.tgz │ └── jitsi-videobridge-1.1-linux-x64-1_es.tgz └── prosody ├── LuaBitOp-1.0.2-x86_64-1_SBo.tgz ├── lbase64-5.1--1_SBo.tgz ├── lua-5.1.5-x86_64-1_SBo.tgz ├── lua-cjson-2.1.0-x86_64-1_SBo.tgz ├── lua-filesystem-1.6.3-x86_64-1_SBo.tgz ├── lua-zlib-20140201_c0014bc-x86_64-1_SBo.tgz ├── luacrypto-0.5.1-x86_64-1_SBo.tgz ├── luaevent-0.4.3-x86_64-1_SBo.tgz ├── luaexpat-1.3.0-x86_64-1_SBo.tgz ├── luarocks-2.4.1-x86_64-1_SBo.tgz ├── luasec-0.7-x86_64-1_SBo.tgz ├── luasocket-3.0_rc1-x86_64-1_SBo.tgz └── prosody-0.10.2-x86_64-1_SBo.tgz For the Java package, we used the Slackware extras SlackBuild located in extra folder of the Slackware distribution.\nWe created startup scripts and a basic configuration files and included them on each package.\nIf you want to build your own, just download the source and run the SlackBuild scripts as usual.\nThe only software we do not created a package for was the Let\u0026rsquo;s Encrypt client.\nPackage installation After building the packages (you can download them from our binary repository), we install them using installpkg as usual.\nBy default the startup scripts are marked for execution and are installed in /etc/rc.d\nThe prosody packages install their software in /usr prefix, while the jisi packages install in /opt prefix.\nWeb server and SSL certificate We have chosen the open source Caddy as our web server. Our package builds the Github version without any plug-ins, and install /etc/rc.d/rc.caddy as a startup script and /etc/caddy/Caddyfile as a default configuration file.\nOur Caddyfile mimics the NGINX configuration provided by the jitsi-meeet team at their repository\nhttps://server.domain.com { root /opt/jitsi-meet tls /etc/acme.sh/server.domain.com/fullchain.cer /etc/acme.sh/server.domain.com/server.domain.com.key rewrite /room.* / proxy /http-bind server.domain.com:5280 log /var/log/caddy/access.log } The rewrite rule only allows this prosody to create rooms that start with the word room. We can be more creative to mimic better the NGINX configuration but this serves our purpose well.\nCaddy integrates with Let\u0026rsquo;s encrypt certificates automatically, but we are going to use acme.sh client because we want to integrate the certificates in other components and open the possibility to change our web server if we need to. See the wiki for the advanced installation proceess.\n# curl https://get.acme.sh | sh -s -- --install --home /etc/acme.sh We want acme.sh to install in /etc becasue the certificates will be read by multiple components of the system.\nTo get our certificates we set up acme.sh to answer Let\u0026rsquo;s encrypt challenge using Cloudflare DNS service:\n# export CF_Key=\u0026#34;asdfgasdfgasdfgasdfg\u0026#34; # export CF_Email=\u0026#34;me@email.com\u0026#34; # acme.sh --issue --dns dns_cf -d server.domain.com -d auth.server.domain.com # Note we need to ask for auth.server.domain.com as well, to use the certificate with prosody. Also note that acme.sh will add a cron job to renew certificates monthly.\nWe can start our web server using /etc/rc.d/rc.caddy start command and check the log files in /var/log/caddy/to search for errors.\nProsody server Prosody is used by the jitsi-meet platform to route messages, enable chat, etc. The configuration file is in /etc/prosody.\nWe need to modify the main configuration file /etc/prosody/prosody.lua.cfg to include the following lines\nplugin_paths = { \u0026#34;/opt/jitsi-meet-token/\u0026#34; } Include \u0026#34;server.domain.com.cfg.lua\u0026#34; With those lines we enable the jitsi-meet plugins for prosody and include a new configuration file which will contain our hosts parameters:\nVirtualHost \u0026#34;server.domain.com\u0026#34; authentication = \u0026#34;token\u0026#34; app_id = \u0026#34;server.domain.com\u0026#34;; app_secret = \u0026#34;jwt-secret\u0026#34;; allow_empty_token = false; ssl = { key = \u0026#34;/etc/acme.sh/server.domain.com/server.domain.com.key\u0026#34;; certificate = \u0026#34;/etc/acme.sh/server.domain.com/fullchain.cer\u0026#34;; } modules_enabled = { \u0026#34;bosh\u0026#34;; \u0026#34;pubsub\u0026#34;; \u0026#34;ping\u0026#34;; } c2s_require_encryption = false Component \u0026#34;conference.server.domain.com\u0026#34; \u0026#34;muc\u0026#34; modules_enabled = { \u0026#34;token_verification\u0026#34; } storage = \u0026#34;internal\u0026#34; admins = { \u0026#34;focus@auth.server.domain.com\u0026#34; } Component \u0026#34;jitsi-videobridge.server.domain.com\u0026#34; component_secret = \u0026#34;videobridge-secret\u0026#34; VirtualHost \u0026#34;auth.server.domain.com\u0026#34; ssl = { key = \u0026#34;/etc/acme.sh/server.domain.com/server.domain.com.key\u0026#34;; certificate = \u0026#34;/etc/acme.sh/server.domain.com/fullchain.cer\u0026#34;; } authentication = \u0026#34;internal_plain\u0026#34; Component \u0026#34;focus.server.domain.com\u0026#34; component_secret = \u0026#34;jicofo-secret\u0026#34; Before starting prosody, we create an user and group called prosody. The log files for prosody will be in /home/prosody. Also we need to copy our certificates to /etc/prosody/certs/ as shown in the configuration file, as prosody user is not able to read them from /root/acme.sh.\nStart prosody server with the command # prosodyctl start and check the log files.\n# prosodyctl register focus auth.jitsi.example.com focus-user-secret # prosodyctl restart Jitsi video bridge server The configuration files for the service are located in /etc/jitsi/videobridge. We need to update the config file with the data of our installation:\n# Jitsi Videobridge settings # sets the XMPP domain (default: none) JVB_HOSTNAME=server.domain.com # sets the hostname of the XMPP server (default: domain if set, localhost otherwise) JVB_HOST= # sets the port of the XMPP server (default: 5275) JVB_PORT=5347 # sets the shared secret used to authenticate to the XMPP server JVB_SECRET=videobridge-secret # extra options to pass to the JVB daemon JVB_OPTS=--apis=rest,xmpp # adds java system props that are passed to jvb (default are for home and logging config file) JAVA_SYS_PROPS=\u0026#34;$JVB_EXTRA_JVM_PARAMS -Dnet.java.sip.communicator.SC_HOME_DIR_LOCATION=/etc/jitsi -Dnet.java.sip.communicator.SC_HOME_DIR_NAME=videobridge -Dnet.java.sip.communicator.SC_LOG_DIR_LOCATION=/var/log/jitsi -Djava.util.logging.config.file=/etc/jitsi/videobridge/logging.properties\u0026#34; Also we need to create the Java Key Store so clients can connect to the video bridge using SSL. We have included in the jitsi-videobridge package a tool called upgrade-cert.sh to create the store for us using the Let\u0026rsquo;s Encrypt certificates:\n#!/bin/bash  ACME=\u0026#34;/etc/acme.sh\u0026#34; SERVER=\u0026#34;server.domain.com\u0026#34; PASSWORD_STORE=\u0026#34;changeit\u0026#34; openssl pkcs12 \\  -export \\  -in $ACME/$SERVER/fullchain.cer \\  -inkey $ACME/$SERVER/$SERVER.key \\  -out $SERVER.p12 \\  -name $SERVER keytool -importkeystore \\  -deststorepass $PASSWORD_STORE \\  -destkeystore $SERVER.jks \\  -srckeystore $SERVER.p12 \\  -srcstoretype PKCS12 \\  -alias $SERVER Customize your server name and password store and run the script to create server.domain.com.jks. Then update the sip-communicator.properties file accordinly (change the port to 4443 instead of 443 on the file to avoid conflicts).\nYou also might want to add the script to run when acme.sh renews the certificates.\nWe start the service using the provided script /etc/rc.d/rc.videobridge start and check the logs in /var/log/jitsi/jvb.log for errors.\nJitsi Conference Focus The configuration files for the service are located in /etc/jitsi/jicofo. We need to update the config file with the data of our installation:\n# Jitsi Conference Focus settings # sets the host name of the XMPP server JICOFO_HOST=localhost # sets the XMPP domain (default: none) JICOFO_HOSTNAME=server.domain.com # sets the secret used to authenticate as an XMPP component JICOFO_SECRET=jicofo-secret # sets the port to use for the XMPP component connection JICOFO_PORT=5347 # sets the XMPP domain name to use for XMPP user logins JICOFO_AUTH_DOMAIN=auth.server.domain.com # sets the username to use for XMPP user logins JICOFO_AUTH_USER=focus # sets the password to use for XMPP user logins JICOFO_AUTH_PASSWORD=focus-user-secret # extra options to pass to the jicofo daemon JICOFO_OPTS=\u0026#34;\u0026#34; # adds java system props that are passed to jicofo (default are for home and logging config file) JAVA_SYS_PROPS=\u0026#34;-Dnet.java.sip.communicator.SC_HOME_DIR_LOCATION=/etc/jitsi -Dnet.java.sip.communicator.SC_HOME_DIR_NAME=jicofo -Dnet.java.sip.communicator.SC_LOG_DIR_LOCATION=/var/log/jitsi -Djava.util.logging.config.file=/etc/jitsi/jicofo/logging.properties\u0026#34; We start the service using the provided script /etc/rc.d/rc.jicofo start and check the logs in /var/log/jitsi/jvb.log for errors.\nJitsi Meet Application The jitsi meet application is in /opt/jitsi-meet. Because the Caddy web server does not have server side includes, we need to edit index.html and include the needed javascript files:\n\u0026lt;script src=\u0026#34;/config.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;libs/do_external_connect.min.js?v=1\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/interface_config.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;/logging_config.js\u0026#34; --\u0026gt;\u0026lt;/script\u0026gt; Also we might want to include the file title.html in the header section of the index.html.\nUsing the service We have configured the service to use JWT authentication. Following the documentation at jitsi-meet repository and using the JWT Debugger at jwt.io, we can generate a link like:\nhttps://server.domain.com/roomXXX?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6Ik...... To enter a room, paste the link into the browser.\n","summary":"\u003cp\u003eFrom it\u0026rsquo;s \u003ca href=\"https://github.com/jitsi/jitsi-meet\"\u003eGithub\u003c/a\u003e page:\u003c/p\u003e\n\n\u003cp\u003eJitsi Meet is an open-source (Apache) WebRTC JavaScript application that uses Jitsi Videobridge to provide high quality, secure and scalable video conferences. You can see Jitsi Meet in action here at the session #482 of the VoIP Users Conference.\u003c/p\u003e\n\n\u003cp\u003eThe Jitsi Meet client runs in your browser, without the need for installing anything on your computer. You can also try it out yourself at \u003ca href=\"https://meet.jit.si\"\u003ehttps://meet.jit.si\u003c/a\u003e .\u003c/p\u003e\n\n\u003cp\u003eJitsi Meet allows for very efficient collaboration. It allows users to stream their desktop or only some windows. It also supports shared document editing with Etherpad.\u003c/p\u003e","tags":["jitsi","howto"],"title":"Jitsi: video conference server","url":"/web/posts/jitsi/"},{"categories":["technology"],"contents":" This document is a derivative of the Slackbook:bash and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.\nWhat Is A Shell? A shell is a program that give access to the operating system\u0026rsquo;s services. In Slackware the command-line interface (CLI) shell is bash, the Bourne Again Shell.\nThe first program Slackware executes after you log into the system is the shell command-line interface:\nThere are many shells included with a full install of Slackware, but in this chapter we will only discuss bash. Advanced users might want to consider using the powerful zsh, and users familiar with older UNIX systems might appreciate ksh or csh, but new users should stick to bash.\nThe main tasks a user does in the shell is executing commands, i.e. telling the computer what to do next.\nUsers can also program in the shell. Programs written in shell language are shell scripts and the Linux kernel execute them as if they were binary programs.\nA lot of Slackware tools are written in bash.\nA complete guide on how to use bash is available in its web. In this chapter we will make a gentle introduction to the bash shell, focused on its use in the Slackware Linux distribution.\nQuick-start So you\u0026rsquo;ve installed Slackware and you\u0026rsquo;re staring at a terminal prompt, what now? Now would be a good time to learn about the basic command-line tools. And since you\u0026rsquo;re staring at a blinking curser, you may need a little help in knowing how to get around.\nWe type a command at the prompt and press the key enter, and the shell executes it. It prints the result of the command below and when the command ends shows the prompt again.\nHere you have a quick reference of commands taken from the fantastic Introduction to Linux by the TLDP:\n ls: List files in the current working directory cd: Change directories passwd: Change the password for the current user file filename: Display file type of file with name filename cat textfile: Throws content of textfile on the screen pwd: Display present working directory exit or logout: Leave the current session man command: Read manual pages on command info command: Read Info pages on command apropos string: Search the whatis database for strings  And a quick reference on how to edit what you type at the prompt:\n Ctrl+A: Move cursor to the beginning of the command line. Ctrl+E: Move cursor to the end of the command line. Ctrl+C: End a running program and return the prompt, see Chapter 4. Ctrl+D: Log out of the current shell session, equal to typing exit or logout. Ctrl+H: Generate a backspace character. Ctrl+L: Clear this terminal. Ctrl+R: Search command history, see Section 3.3.3.4. Ctrl+Z: Suspend a program, see Chapter 4. ArrowLeft and ArrowRight: Move the cursor one place to the left or right on the command line, so you can insert characters at other places than just at the beginning and the end. ArrowUp and ArrowDown: Browse history. Go to the line you want to repeat, edit details and press Enter to save time. Shift+PageUp and Shift+PageDown: Browse terminal buffer (to see text that has \u0026ldquo;scrolled off\u0026rdquo; the screen). Tab: Command or filename completion; when multiple choices are possible, the system will either signal with an audio or visual bell, or, if too many choices are possible, ask you if you want to see them all. Tab Tab (Tab twice): Shows file or command completion possibilities.  The prompt It is the message the shell prints to show it is ready to accept new instructions. bash generates the prompt based in a template. The default template in Slackware is \\u@\\h:\\w\\$ which generate prompts like root@darkstar:~#. \\u stands for the user name, \\h stands for the host name \\w stands for the current path in the filesystem and \\$ shows if the user has administration privileges # or not $.\nPS1 variable contains the template to configure the prompt.\nConfiguration The shell is configured editing the following files, depending on what kind of configuration we want to make.\n /etc/profile: The systemwide initialization file, executed for login shells ~/.bash_profile: The personal initialization file, executed for login shells ~/.bashrc: The individual per-interactive-shell startup file ~/.bash_logout: The individual login shell cleanup file, executed when a login shell exits ~/.inputrc: Individual readline initialization file  Those files accept bash commands as their content, and those commands are the ones which will configure the bash environment when it starts.\nEnvironment An environment is a compound of properties and variables defined in the shell when it starts. We can change most without restarting the shell.\nAll shells make certain tasks easier for the user by keeping track of things in environment variables. An environment variable is a shorter name for some bit of information that the user wishes to store and make use of later. For example, the environment variable PS1 tells bash how to format its prompt. Other variables may tell applications how to run.\nSetting your own environment variables is easy. bash includes two built-in functions for handling this: set and export. We can remove an environment with unset. Don\u0026rsquo;t panic if you accidentally unset an environment variable and don\u0026rsquo;t know what it would do. You can reset all the default variables by logging out of your terminal and logging back in. You can reference a variable by placing a dollar sign ($) in front.\ndarkstar:~$ set FOO=bar darkstar:~$ echo $FOO bar The primary difference between set and export is that export will make the variable available to any sub-shells. (A sub-shell is another shell running inside a parent shell.) You can see this behavior when working with the PS1 variable that controls the bash prompt.\ndarkstar:~$ set PS1=\u0026#39;FOO \u0026#39; darkstar:~$ export PS1=\u0026#39;FOO \u0026#39; FOO There are many important environment variables that bash and other shells use, but one of the most important ones you will run across is PATH. It contains a list of directories to search through for applications.\nFor example, top is in /usr/bin/top. You could run it by specifying the complete path, but if /usr/bin is in your PATH variable, bash will check there for you when you type top at the prompt. You will most likely first notice this when you try to run a program and it is not in your PATH.\ndarkstar:~$ ifconfig bash: ifconfig: command not found darkstar:~$ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/opt/www/htdig/bin:. Above, you see a typical PATH for a regular user (see the $ in the prompt). You can change it on your own the same as any other environment variable. If you login as root however, you\u0026rsquo;ll see that root has a different PATH.\ndarkstar:~$ su - Password: darkstar:~# echo $PATH /usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/opt/www/htdig/bin Writing commands (II) Wildcards Wildcards are symbols used as placeholders for other characters. The use case for these in a shell is to complete strings like file names.\nThe asterisk matches any character or a characters combination, including none. Thus b* would match strings like b, ba, bab, babc, bcdb, and so forth. Less common is the ?. This wildcard matches one instance of any character, so b? would match ba and bb, but not b or bab.\ndarkstar:~$ touch b ba bab darkstar:~$ ls * b ba bab darkstar:~$ ls b? ba No, the fun doesn\u0026rsquo;t stop there! Besides these two we also have the bracket pair \u0026ldquo;[ ]\u0026rdquo; which allows us to fine tune what we want to match. Whenever bash see the bracket pair, it substitutes the contents of the bracket with any combination of letters or numbers specified, as long as they are comma separated.\ndarkstar:~$ ls a[1-4,9] a1 a2 a3 a4 a9 We can specify a range of letters or numbers typing a - between the start and the end of the range.\nbash treat capital and lower-case letters as different. All capital letters come before all lower-case letters in alphabetical order. This is important when working with ranges.\ndarkstar:~$ ls 1[W-b] 1W 1X 1Y 1Z 1a 1b darkstar:~$ ls 1[w-B] /bin/ls: cannot access 1[b-W]: No such file or directory In the second example, 1[b-W] isn\u0026rsquo;t a valid range, so the shell treats it as a filename, and since that file doesn\u0026rsquo;t exist, ls tells you so.\nTab Completion bash completes your commands and filenames when you write just press the key Tab. Even if you haven\u0026rsquo;t typed in enough text to identify a filename or command, the shell will fill in as much as it can for you. Hitting Tab a second time will make it display a list of all matches for you.\nInput and Output Redirection One of the defining features of Linux and other UNIX-like operating systems is the number of small, simple applications and the ability to stack them together to create complex systems. In bash we can make the output of a command the input of another one or into a file.\nA shell command has three channels to control its input/output operations:\n The standard output (stdout or 1) is where the commands write their result The standard error (stderr or 2) is where the commands write their errors The standard input (stdin or 0) is where the commands read their input  To get started, we will show you how to redirect the output (stdout) of a program to a file. We do this with the \u0026gt; character. When bash sees the \u0026gt; character, it redirects all the output to whatever file name follows.\ndarkstar:~$ echo foo foo darkstar:~$ echo foo \u0026gt; /tmp/bar darkstar:~$ cat /tmp/bar foo If we do not redirect the stdout of echo, it prints the string given as its argument to its stdout. But if we redirect that stdout to a file we cannot see the output of the echo command.\nIf /tmp/bar does not exist, bash creates it and write the output as its contents. If /tmp/bar exist, then its contents are over-written. This might not be the best idea if you want to keep those contents in place.\nbash supports \u0026gt;\u0026gt; which will append the output to the file, instead of over-write it.\ndarkstar:~$ echo foo foo darkstar:~$ echo foo \u0026gt; /tmp/bar darkstar:~$ cat /tmp/bar foo darkstar:~$ echo foo2 \u0026gt;\u0026gt; /tmp/bar darkstar:~$ cat /tmp/bar foo foo2 You can also re-direct the standard error to a file using 2\u0026gt; instead of just \u0026gt;.\ndarkstar:~$ rm bar rm: cannot remove `bar\u0026#39;: No such file or directory darkstar:~$ rm bar 2\u0026gt; /tmp/foo darkstar:~$ cat /tmp/foo rm: cannot remove `bar\u0026#39;: No such file or directory You may also redirect the standard input with the \u0026lsquo;\u0026lt;\u0026rsquo; character, though it\u0026rsquo;s not used often.\ndarkstar:~$ fromdos \u0026lt; dosfile You can redirect the output of one program as input to another using the | character. bash uses pipes to connect the stdout of a command to the stdin of another.\ndarkstar:~$ ps auxw | grep getty root 2632 0.0 0.0 1656 532 tty2 Ss+ Feb21 0:00 /sbin/agetty 38400 tty2 linux root 3199 0.0 0.0 1656 528 tty3 Ss+ Feb15 0:00 /sbin/agetty 38400 tty3 linux root 3200 0.0 0.0 1656 532 tty4 Ss+ Feb15 0:00 /sbin/agetty 38400 tty4 linux root 3201 0.0 0.0 1656 532 tty5 Ss+ Feb15 0:00 /sbin/agetty 38400 tty5 linux root 3202 0.0 0.0 1660 536 tty6 Ss+ Feb15 0:00 /sbin/agetty 38400 tty6 linux Task Management bash has yet another cool feature to offer: the ability to suspend and resume tasks. This allows you halt a running process, perform other task, then resume it or make it run in the background. Upon pressing CTRL-Z,bash will suspend the running process and return you to a prompt. You can return to that process later. You can suspend multiple processes in this way. The jobs built-in command will display a list of suspended tasks.\ndarkstar:~$ jobs [1]- Stopped vi TODO [2]+ Stopped vi chapter_05.xml To return to a suspended task, run the fg built-in to bring the last suspended task back into the foreground. If you have multiple suspended tasks, you can specify a number as well to bring one to the foreground.\ndarkstar:~$ fg # \u0026#34;vi TODO\u0026#34; darkstar:~$ fg 1 # \u0026#34;vi chapter_05.xml\u0026#34; You can also background a task with bg. This allows the process to run without maintaining control of your shell. You can bring it back to the foreground with fg in the same way as suspended tasks. Also, if you type \u0026amp; at the end of a command, bash send it to the background.\nTerminals Terminals were keyboards and monitors (sometimes even mice) wired into a mainframe or server via serial connections. Today however, most terminals are virtual. This allow users to connect to the computer without requiring expensive and often incompatible hardware.\nSlackware Linux and other UNIX-like operating systems use virtual terminals to interact with its users.\nThe most common virtual terminals (every Slackware Linux machine will have at least one) are the gettys. agetty(8) runs six instances by default on Slackware and allows local users (those who can sit down in front of the computer and type at the keyboard) to login and run applications. Each of these gettys is available on different tty devices that are accessible by pressing the ALT key and one of the function keys from F1 through F6. Using these gettys allows you to login multiple times, perhaps as different users, and run applications in those users\u0026rsquo; shells.\nOn desktops, laptops, and other workstations where the user prefers a graphical interface, most terminals are graphical. Slackware includes many graphical terminals, but the most used are KDE\u0026rsquo;s konsole, XFCE's Terminal and the standard xterm.\nIf you are using a graphical interface, check your toolbars or menus. Each desktop environment or window manager has a virtual terminal (often called a terminal emulator), and they are all labeled differently. Typically though, you will find them under a \u0026ldquo;System\u0026rdquo; sub-menu in desktop environments. Executing any of these will give you a graphical terminal and automatically run your default shell.\nBasic shell commands System Documentation Your Slackware Linux system comes with lots of built-in documentation for nearly every installed application. Perhaps the most common method of reading system documentation is man. man (short for manual) will bring up the included man-page for any application, system call, a configuration file, or library you tell it too. For example, man man will bring up the man-page for itself.\nYou may not always know what application you need to use for the task at hand. But man has built-in search abilities to help. Using the [-k] switch will make man to search for every man-page that matches your search terms.\nThe man-pages are organized into groups or sections by their content type. For example, Section 1 is for user applications. man will search each section in order and display the first match it finds. Sometimes you find that a man-page exists in more than one section for an entry. In that case, you will need to specify the exact section to look in.\nIn this book, all applications and several other things will have a number on their right-hand side in parentheses. This number is the man page section where you will find information on that tool.\ndarkstar:~$ man -k printf printf (1) - format and print data printf (3) - formatted output conversion darkstar:~$ man 3 printf The sections of the manual pages are: - Section 1: User Commands - Section 2: System Calls - Section 3: C Library Calls - Section 4: Devices - Section 5: File Formats / Protocols - Section 6: Games - Section 7: Conventions / Macro Packages - Section 8: System Administration - Section 9: Kernel API Descriptions - Section n: \u0026ldquo;New\u0026rdquo; - typically used to Tcl/Tk\nFiles and directories: The filesystem  In computing, a file system or filesystem controls how data is stored and retrieved. Without a file system, information placed in a storage medium would be one large body of data with no way to tell where one piece of information stops and the next begins. By separating the data into pieces and giving each piece a name, the information is easily isolated and identified. Taking its name from the way paper-based information systems are named, each group of data is called a \u0026#34;file\u0026#34;. The structure and logic rules used to manage the groups of information and their names is called a \u0026#34;file system\u0026#34; Wikipedia  In Slackware and other UNIX-like operating systems, the file systems is a hierarchical tree-like structure which starts at the root directory denoted by /. All other directories and files are referenced from its relation to the root.\nListing Files and Directory Contents We use ls(1) to list files and directories, their permissions, size, type, inode number, owner and group, and plenty of additional information. For example, let\u0026rsquo;s list what\u0026rsquo;s in the / directory for your new Slackware Linux system.\ndarkstar:~$ ls / bin/ dev/ home/ lost+found/ mnt/ proc/ sbin/ sys/ usr/ boot/ etc/ lib/ media/ opt/ root/ srv/ tmp/ var/ Notice that each of the listings is a directory. These are distinguished from regular files due to the trailing /; standard files do not have a suffix. Executable files will have an asterisk suffix. But ls can do so much more. To get a view of the permissions of a file or directory, you must do a \u0026ldquo;long list\u0026rdquo;.\ndarkstar:~$ ls -l /home/alan/Desktop -rw-r--r-- 1 alan users 15624161 2007-09-21 13:02 9780596510480.pdf -rw-r--r-- 1 alan users 3829534 2007-09-14 12:56 imgscan.zip drwxr-xr-x 3 alan root 168 2007-09-17 21:01 ipod_hack/ drwxr-xr-x 2 alan users 200 2007-12-03 22:11 libgpod/ drwxr-xr-x 2 alan users 136 2007-09-30 03:16 playground/ A long listing lets you view the permissions, user and group ownership, file size, last modified date, and the file name itself. Notice that the first two entire are files, and the last three are directories. This is denoted by the first character on the line. Regular files get a \u0026ldquo;-\u0026rdquo;; directories get a \u0026ldquo;d\u0026rdquo;. There are several other file types with their own denominators. Symbolic links for example will have an \u0026ldquo;l\u0026rdquo;.\nWe\u0026rsquo;ll show you how to list dot-files, or hidden files. Unlike other operating systems such as Microsoft Windows, there is no special property that differentiates \u0026ldquo;hidden\u0026rdquo; files from \u0026ldquo;unhidden\u0026rdquo; files. A hidden file begins with a dot. To display these files along with all the others, you need to pass the [-a] argument to ls.\ndarkstar:~$ ls -a .xine/ .xinitrc-backup .xscreensaver .xsession-errors SBo/ .xinitrc .xinitrc-xfce .xsession .xwmconfig/ Shared/ You also likely noticed that your files and directories appear in different colors. Many of the enhanced features of ls such as these colors or the trailing characters showing file-type are special features of the ls program enabled by passing various arguments. As a convenience, Slackware sets up ls to use many of these optional arguments by default. These are controlled by the LS_OPTIONS and LS_COLORS environment variables.\nMoving Around the Filesystem cd is the command used to change directories. Unlike most other commands, cd is not it\u0026rsquo;s own program, but is a shell built-in. That means cd does not have its own man page. You must check your shell\u0026rsquo;s documentation for more details on the cd you may be using. Mostly though, they all behave the same.\ndarkstar:~$ cd / darkstar:/$ls bin/ dev/ home/ lost+found/ mnt/ proc/ sbin/ sys/ usr/ boot/ etc/ lib/ media/ opt/ root/ srv/ tmp/ var/ darkstar:/$cd /usr/local darkstar:/usr/local$ Notice how the prompt changed when we changed directories? The default Slackware shell does this as a quick, easy way to see your current directory, but this is not a cd function. If your shell doesn\u0026rsquo;t operate in this way, you can get your current working directory with the pwd(1) command.\nbash4.4$ pwd /usr/local File and Directory Creation and Deletion While most applications can and will create their own files and directories, you\u0026rsquo;ll often want to do this on your own. It\u0026rsquo;s easy using touch(1) and mkdir(1).\ntouch modifies the time stamp on a file, but if that file doesn\u0026rsquo;t exist, it will be created.\ndarkstar:~/foo$ ls -l -rw-r--r-- 1 alan users 0 2012-01-18 15:01 bar1 darkstar:~/foo$ touch bar2 -rw-r--r-- 1 alan users 0 2012-01-18 15:01 bar1 -rw-r--r-- 1 alan users 0 2012-01-18 15:05 bar2 darkstar:~/foo$ touch bar1 -rw-r--r-- 1 alan users 0 2012-01-18 15:05 bar1 -rw-r--r-- 1 alan users 0 2012-01-18 15:05 bar2 Note how bar2 was created in our second command, and the third command updated the time stamp on bar1.\nmkdir is used for making directories. mkdir foo will create the directory foo within the current working directory. You can also use the -p argument to create any missing parent directories.\ndarkstar:~$ mkdir foo darkstar:~$ mkdir /slack/foo/bar/ mkdir: cannot create directory `/slack/foo/bar/\u0026#39;: No such file or directory darkstar:~$ mkdir -p /slack/foo/bar/ In the latter case, mkdir will first create /slack, then /slack/foo, and /slack/foo/bar. If you failed to use the [-p] argument, man would fail to create /slack/foo/bar unless the first two already existed, as you saw in the example.\nRemoving a file is as easy as creating one. The rm(1) command will remove a file (assuming you have permission to do this). There are a few common arguments to rm. The first is [-f] and is used to force the removal of a file you may lack explicit permission to delete. The [-r] argument will remove directories and their contents recursively.\nThere is another tool to remove directories, the humble rmdir(1). rmdir will only remove directories that are empty and complain about those that contain files or sub-directories.\ndarkstar:~$ ls foo_1/ foo_2/ darkstar:~$ ls foo_1 bar_1 darkstar:~$ rmdir foo_1 rmdir: foo/: Directory not empty darkstar:~$ rm foo_1/bar darkstar:~$ rmdir foo_1 darkstar:~$ ls foo_2 bar_2/ darkstar:~$ rm -fr foo_2 darkstar:~$ ls Links Links are a method of referring to one file by multiple names. By using the ln(1) application, a user can reference one file with multiple names. The two files are not carbon-copies of one another, but rather are the same file, just with a different name. To remove the file, all of its names must be deleted. (This is the result of how rm and other tools like it work. Rather than remove the contents of the file, they remove the reference to the file, freeing that space to be re-used. ln will create a second reference or \u0026ldquo;link\u0026rdquo; to that file.)\ndarkstar:~$ ln /etc/slackware-version foo darkstar:~$ cat foo Slackware 14.0 darkstar:~$ ls -l /etc/slackware-version foo -rw-r--r-- 1 root root 17 2007-06-10 02:23 /etc/slackware-version -rw-r--r-- 1 root root 17 2007-06-10 02:23 foo Another type of link exists, the symlink. Symlinks, rather than being another reference to the same file, are a special file in their own right. These symlinks point to another file or directory. The primary advantage of symlinks is that they can refer to directories and files, and they can span multiple filesystems. We create them with the [-s] argument.\ndarkstar:~$ ln -s /etc/slackware-version foo darkstar:~$ cat foo Slackware 140 darkstar:~$ ls -l /etc/slackware-version foo -rw-r--r-- 1 root root 17 2007-06-10 02:23 /etc/slackware-version lrwxrwxrwx 1 root root 22 2008-01-25 04:16 foo -\u0026gt; /etc/slackware-version When using symlinks, remember that if the original file is deleted, your symlink is useless; it points at a file that doesn\u0026rsquo;t exist anymore.\nReading files UNIX and UNIX-like operating systems use text files extensively, and that at some point in time, the system\u0026rsquo;s users will need to read and modify them. There are plenty of ways of reading these files, and we\u0026rsquo;ll show you the most common ones.\nIn the early days, if you wanted to see the contents of a file you would use cat(1) to view them. cat is a simple program, which takes one or more files, concatenates them (hence the name) and sends them to the standard output, which is usually your terminal screen.\nThis was fine when the file was small and wouldn\u0026rsquo;t scroll off the screen, but inadequate for larger files as it had no built-in way of moving within a document and reading it a paragraph at a time. Today, cat is still used predominately in scripts or for joining two or more files into one.\ndarkstar:~$ cat /etc/slackware-version Slackware 14.2 Given the limitations of cat some very intelligent people sat down and worked on an application to let them read documents one page at a time. Such applications began to be known as \u0026ldquo;pagers\u0026rdquo;. One of the earliest of these was more(1), named because it would let you see \u0026ldquo;more\u0026rdquo; of the file whenever you wanted.\nmore more will display the first few lines of a text file until your screen is full, then pause. Once you\u0026rsquo;ve read through that screen, you can proceed down one line by pressing Enter, or an entire screen by pressing Space, or by a specified number of lines by typing a number and then the Space bar. more can also search through a text file for keywords; once you\u0026rsquo;ve displayed a file in more, press the / key and enter a keyword. Upon pressing Enter, the text will scroll until it finds the next match.\nThis is a big improvement over cat, but still suffers from some annoying flaws; more cannot scroll back up through a piped file to allow you to read something you might have missed, the search function does not highlight its results, there is no horizontal scrolling, and so on.\nless To address the short-comings of more, a new pager was developed and ironically dubbed less(1). less is a powerful pager that supports all the functions of more while adding lots of additional features. To begin with, less allows you to use your arrow keys to control movement within the document.\nDue to its popularity, many Linux distributions have excluded more in favor of less. Slackware includes both. Slackware also includes a handy little pre-processor for less called lesspipe.sh. This allows a user to execute less on several non-text files. lesspipe.sh will generate text output from running a command on these files, and display it in less.\nLess provides as much functionality as one might expect from a text editor without being a text editor. We can move line-by-line can be done vi-style with j and k, or with the arrow keys, or Enter. In the event that a file is too wide to fit on one screen, you can even scroll with the left and right arrow keys. The g key takes you to the top of the file, while G takes you to the end.\nSearching is done as with more, by typing the / key and then your search string, but notice how the search results are highlighted for you, and typing n will take you to the next occurrence of the result while N takes you to the previous occurrence.\nAlso as with more, files may be opened directly in less or piped to it:\ndarkstar:~$ less /usr/doc/less-*/README darkstar:~$ cat /usr/doc/less*/README /usr/doc/util-linux*/README | less There is much more to less; from within the application, type h for a full list of commands.\nArchive and Compression Everyone needs to package a lot of small files together for easy storage from time to time, or perhaps you need to compress very large files into a more manageable size? Maybe you want to do both together? there are several tools to do just that.\nzip and unzip You\u0026rsquo;re probably familiar with .zip files. These are compressed files that contain other files and directories.\nTo create a zip file, you\u0026rsquo;ll use the zip(1) command. You can compress either files or directories (or both) with zip, but you must use the [-r] argument for recursive action to deal with directories.\ndarkstar:~$ zip -r /tmp/home.zip /home darkstar:~$ zip /tmp/large_file.zip /tmp/large_file The order of the arguments is very important. The first filename must be the zip file to create (zip will add the .zip file extension for you) and the rest are files or directories to be added to the zip file.\nunzip(1) will decompress a zip archive file.\ndarkstar:~$ unzip /tmp/home.zip gzip One of the oldest compression tools included in Slackware is gzip(1), a compression tool which operate on a single file at a time or stream at a time. While zip is both a compression and an archival tool, gzip does only compression. At first glance this seems like a draw-back, but it is a strength. The UNIX philosophy of making small tools that do their small jobs well allows us to combine them in myriad ways. To compress a file (or multiple files), pass them as arguments to gzip. Whenever gzip compresses a file, it adds a .gz extension and removes the original file.\ndarkstar:~$ gzip /tmp/large_file Decompressing is just as straight-forward with gunzip which will create a new uncompressed file and delete the old one.\ndarkstar:~$ gunzip /tmp/large_file.gz darkstar:~$ ls /tmp/large_file* /tmp/large_file But suppose we don\u0026rsquo;t want to delete the old compressed file, we want to read its contents or send them as input to another program? The zcat program will read the gzip file, decompress it in memory, and send the contents to the standard output.\ndarkstar:~$ zcat /tmp/large_file.gz Wed Aug 26 10:00:38 CDT 2009 Slackware 13.0 x86 is released as stable! Thanks to everyone who helped make this release possible -- see the RELEASE_NOTES for the credits. The ISOs are off to the replicator. This time it will be a 6 CD-ROM 32-bit set and a dual-sided 32-bit/64-bit x86/x86_64 DVD. We\u0026#39;re taking pre-orders now at store.slackware.com. Please consider picking up a copy to help support the project. Once again, thanks to the entire Slackware community for all the help testing and fixing things and offering suggestions during this development cycle. bzip2 One alternative to gzip is the bzip2(1)xt compression utility which works in almost the same way. The advantage to bzip2 is that it boasts greater compression strength. Achieving that greater compression is a slow and CPU-intensive process, so bzip2 typical takes much longer to run than other alternatives.\nXZ / LZMA The latest compression utility added to Slackware is xz, which implements the LZMA compression algorithm. This is faster than bzip2 and often compresses better. In fact, its blend of speed and compression strength caused it to replace gzip as the compression scheme of choice for Slackware. We can compress files using the [-z] argument, and decompression with [-d].\ndarkstar:~$ xz -z /tmp/large_file tar So great, we know how to compress files using many programs, but none of them can archive files like zip does.\nThe Tape Archiver, or tar(1) is the most used archival program in Slackware. Like other archival programs, tar generates a new file that contains other files and directories. It does not compress the generated file (often called a \u0026ldquo;tarball\u0026rdquo;) by default; however, the version of tar included in Slackware supports a variety of compression schemes, including the ones mentioned above.\nInvoking tar can be as easy or as complicated as you like. Creating a tarball is done with the [-cvzf] arguments. Let\u0026rsquo;s look at these in depth.\n c: create a tarball x: extract the contents of a tarball t: display the contents of a tarball v: be more verbose z: use gzip compression j: use bzip2 compression J: use LZMA compression p: preserve permissions  tar requires more precision than other applications in the order of its arguments. The [-f] argument must be present when reading or writing to a file for example, and the very next thing to follow must be the filename. Consider the following examples.\ndarkstar:~$ tar -xvzf /tmp/tarball.tar.gz darkstar:~$ tar -xvfz /tmp/tarball.tar.gz Above, the first example works as you would expect, but the second fails because tar was told to open the z file rather than the expected /tmp/tarball.tar.gz.\nNow we\u0026rsquo;ve got our arguments straightened out, lets look at a few examples of how to create and extract tarballs. As we\u0026rsquo;ve noted, the [-c] argument is used to create tarballs and [-x] extracts their contents. If we want to create or extract a compressed tarball though, we also have to specify the proper compression to use. If we don\u0026rsquo;t want to compress the tarball at all, we can leave these options out. The following command creates a new tarball using the gzip compression algorithm. While it\u0026rsquo;s not a strict requirement, it\u0026rsquo;s also good practice to add the .tar extension to all tarballs and whatever extension is used by the compression algorithm.\ndarkstar:~$ tar -czf /tmp/tarball.tar.gz /tmp/tarball/ ","summary":"This document is a derivative of the Slackbook:bash and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.\nWhat Is A Shell? A shell is a program that give access to the operating system\u0026rsquo;s services. In Slackware the command-line interface (CLI) shell is bash, the Bourne Again Shell.\nThe first program Slackware executes after you log into the system is the shell command-line interface:","tags":["build","how-to"],"title":"Shell","url":"/web/docs/shell/"},{"categories":["documentation"],"contents":"In this post we will explore how to free disk space without reinstalling the system, and will present some scripts to help in the process.\nIntroduction After some time using your system, installing new software and trying out settings, it\u0026rsquo;s inevitable to find that the disk usage is growing.\nIt could be a daunting process to free disk space, and most people will reinstall the systems again, adding to the new installation the experience got with the old one.\nIt\u0026rsquo;s common to think the in the new system, this problem will go away because you\u0026rsquo;ve learned a lot, and the system space will remain low, while only your data will increase. But on my experience, most people install again the operating system to clean it out.\nA new installed Slackware, using the recommended installation process, installs aournd 10GB of software in your computer. But poking around and trying out software, can get you to 40GB in no time.\nOur strategy to clean up the system will be:\n check the filesystem to see where is used the space check temporary files check installed packages and see how much space the use check files which do not belong to any package  Useful tools There are multiple tools to get information about filesystem usage, for example:\n xdiskusage   xdiskusage analisys of /     ncdu  ncdu showing / disk usage statistics   But sometimes we need to understand the problem to be able to use those tools correctly. Also if you make our own tools we will be able to automate certain tasks.\nFilesystem usage The du utility, which stands for disk usage, can give you the size of a file or a folder.\nWith no arguments du will print the size of all files and folders from the current folder. And with the options -s and -h will summarize and print information of the current folder converting the size from Kb to the biggest unite possible (Mb, Gb, etc.)\ngdiazlo@darkstar:~$ du -sh 9.4G . gdiazlo@darkstar:~$  It also accepts a parameter to show which folder is the starting point to calculate sizes:\ngdiazlo@darkstar:~$ du -sh $HOME 9.4G . gdiazlo@darkstar:~$  So knowing where is the space going, it might tempt us to do\ngdiazlo@darkstar:~$ du -sh /* but be aware: du will try to calculate the size of all mounted filesystems, including CD-ROMs, network shares, and synthetic filesystems like /proc. That will slow the process or even show errors.\nA solution found in superuser.com site works well on a system with multiple mounted filesystems.\nroot@darkstar:~# for a in /*; do mountpoint -q -- \u0026#34;$a\u0026#34; || du -s -h -x \u0026#34;$a\u0026#34;; done 13M /bin 35M /boot 31M /etc 9.4G /home 559M /lib 27M /lib64 16K /lost+found 64K /media 56K /mnt 212M /opt 1.9G /root 24M /sbin 4.0K /srv 4.9G /tmp 16G /usr 4.9G /var root@darkstar:~#  We can see in the list the top 5 space users:\n /usr uses 16G of space /home uses 9.5G of space /var uses 4.9G of space /tmp uses 4.9G of space /root uses 1.9G of space  All that combined is 37.2G of space.\nThe space used in /usr and /var should correspond to files from the operating system: installed software, packages, logs, databases, and together they account for 20.9G of space.\nThe space used in /tmp should be disposable as it only serves the purpose to contain ephemeral information.\nAnd the /rootand/home` contain personal files from the administrator and the users of the computer.\nWith this information we state a different strategy to each case:\n system files: check packages and files that do not belong to any installed package temporary files: delete them if possible administrator and user files: check the downloads and temporary files, delete on your discretion  Identify system files We read about package managemt in Slackware to devise an strategy to:\n calculate the space used by installed packages identify orphan files (not related to any package) and their disk usage  Disk usage by installed packages We analize the space each packae uses throught its metadata files stored in /var/log/packages.\nTo show the packages ordered by its uncompressed size in ascending order:\n#!/bin/bash  for p in `ls -1 /var/log/packages`; do head -n 3 /var/log/packages/$p | awk \u0026#39; /PACKAGE NAME:/ { name=$3 } /UNCOMPRESSED PACKAGE SIZE:/ { size=$4 } END{ print size, \u0026#34; \u0026#34; , name }\u0026#39; done | numfmt --from=si | sort -n -k 1 | numfmt --to=si The script is not very fast, but produce good results:\nroot@darkstar:~# ./pkgsize-meta | tail -n 10 168M emacs-26.1-x86_64-1 176M seamonkey-2.49.4-x86_64-1 220M kernel-modules-4.14.60-x86_64-1 285M mariadb-10.3.8-x86_64-1 297M kernel-firmware-20180730_7b5835f-noarch-1 335M qt5-5.11.1-x86_64-1alien 428M texlive-2018.180630-x86_64-2 529M rust-1.28.0-x86_64-1 718M llvm-6.0.1-x86_64-1 800M kernel-source-4.14.60-noarch-1 root@darkstar:~# Another example is calculate the size of all packages toghether:\nroot@darkstar:~# ./pkgsize-meta | numfmt --from=si | awk \u0026#39;{print $1}\u0026#39; | paste -sd+ | bc | numfmt --to=si 13G root@darkstar:~#  An installed file can grow over time, and this script will not take that into account. We can look in the disk ourselves instead of using the size provided by the package\u0026rsquo;s metadata file:\n#!/bin/bash  PKGS=\u0026#34;/var/log/packages\u0026#34; LOGFILE=$(mktemp /tmp/pkgsize.XXXXXX) packages=$(ls -1 ${PKGS}/$1) total=0 for p in ${packages[@]}; do files=($(cat $p | sed \u0026#39;1,/FILE LIST/d\u0026#39; | sed \u0026#39;s/^/\\//g\u0026#39; | grep -v \u0026#34;\\/$\u0026#34; )) pkgsize=$( for i in $(seq 0 200 ${#files[@]}); do echo $(stat --printf=\u0026#34;%s \u0026#34; ${files[@]:$i:200} 2\u0026gt;$LOGFILE) | sed \u0026#39;s/ /\\n/g\u0026#39; done | paste -sd+ | bc ) echo $pkgsize $p | numfmt --to=si total=$(( total + pkgsize )) done echo $total | numfmt --to=si \u0003\nroot@darkstar:~# ./pkgsize kernel-source-* 784M /var/log/packages/kernel-source-4.14.60-noarch-1 784M In the examples, the kernel package reported to use 800M in the metadata file and 784M using stat agains all the files and adding the result.\nWith this information we may decide to delete the packages we don\u0026rsquo;t use.\nIdentify orphan files An orphan file does not correspond to any installed package. This could mean is software or data generated during the system use. Maybe we installed or tried to install applications that polluted our system with files and didn\u0026rsquo;t user the package management tools.\nTo decrease the number of orphan files, use Appimage or flatpak to install software which do not have a package for Slackware. Also consider making your own packages, it is easy and allows you to control all the files on your system.\nWe can devise a script to find all orphan files and list them along with their size in Kb. Be aware this script is slow and requires a considerable amount of RAM (around 400M on our case). See the contribution below for a better approach.\n#!/bin/bash  LOGFILE=$(mktemp /tmp/pkgorphan.XXXXXX) files=() TMP=$(mktemp -d /tmp/orphan.XXXXXX) cd $TMP for p in `ls -1 /var/log/packages`; do cat /var/log/packages/$p |sed -e \u0026#39;1,/FILE LIST/d\u0026#39; | sed \u0026#39;s/^/\\//g\u0026#39; | sed \u0026#39;s/\\/$//g\u0026#39; done | sort -u \u0026gt; meta for i in usr bin sbin lib lib64 opt srv var etc root; do find /$i -type f done | sort -u \u0026gt; disk awk \u0026#39;NR==FNR { A[$1] ; next } !($1 in A) { print $1 }\u0026#39; meta disk \u0026gt; orphans files=($(cat orphans)) for i in $(seq 0 200 ${#files[@]}); do ls -d -s -1 ${files[@]:$i:200} 2\u0026gt;$LOGFILE done \u0026gt; orphans-size A brave soul on #irc contributed another way to look for orphans, with better performance:\n#!bin/bash # This needs bash for arrays # # Author: Jakub Jankowski \u0026lt;shasta@slackware.pl\u0026gt; # ONLY_FSTYPES_RGXP=\u0026#39;^(btrfs|ext[234]|xfs|jfs)$\u0026#39; SKIP_PATHS=( \u0026#39;/root/*\u0026#39; \u0026#39;/home/*\u0026#39; \u0026#39;/mnt/*\u0026#39; \u0026#39;/var/run/*\u0026#39; \u0026#39;/var/tmp/*\u0026#39; \u0026#39;/var/spool/*\u0026#39; \u0026#39;/var/log/pkgtools/*\u0026#39; \u0026#39;/var/lib/pkgtools/*\u0026#39; \u0026#39;/var/lib/sbopkg/*\u0026#39; \u0026#39;/var/cache/lxc/*\u0026#39; \u0026#39;/usr/src/linux*\u0026#39; \u0026#39;/tmp/*\u0026#39; ) # create temporary files FROM_PKGS=$(mktemp) FROM_FS=$(mktemp) set -e # list all files/dirs brought by packages; # we are also stripping .new suffix as that\u0026#39;s how config # files come in, but they are later mv\u0026#39;d \u0026#34;foo.new\u0026#34; \u0026#34;foo\u0026#34; for pkg in /var/log/packages/*; do sed -e \u0026#39;1,/^FILE LIST:/d; /^\\.\\/$/d; /^install\\//d; s,^,/,; s,\\.new$,,; s,/$,,\u0026#39; \u0026#34;$pkg\u0026#34; done \u0026gt; \u0026#34;$FROM_PKGS\u0026#34; # find all files/directories on filesystem, but only if fs type is one of $ONLY_FSTYPES_RGXP; # on\u0026#39;t descend to other filesystems (-xdev), and ignore paths from $SKIP_PATHS declare -a EXCL=( ) for p in \u0026#34;${SKIP_PATHS[@]}\u0026#34;; do if [ ${#EXCL[@]} -eq 0 ]; then EXCL=( \u0026#34;${EXCL[@]}\u0026#34; \u0026#39;-path\u0026#39; \u0026#34;$p\u0026#34; \u0026#39;-prune\u0026#39; ) else EXCL=( \u0026#34;${EXCL[@]}\u0026#34; \u0026#39;-o\u0026#39; \u0026#39;-path\u0026#39; \u0026#34;$p\u0026#34; \u0026#39;-prune\u0026#39; ) fi done [ ${#EXCL[@]} -gt 0 ] \u0026amp;\u0026amp; EXCL=( \u0026#34;${EXCL[@]}\u0026#34; \u0026#39;-o\u0026#39; \u0026#39;-print\u0026#39; ) find $(awk -v fstypes=\u0026#34;$ONLY_FSTYPES_RGXP\u0026#34; \u0026#39;$3 ~ fstypes {print $2}\u0026#39; /proc/mounts) \\  -xdev \u0026#34;${EXCL[@]}\u0026#34; 2\u0026gt;/dev/null \u0026gt; \u0026#34;$FROM_FS\u0026#34; # output needs to be sorted for join(1) to work LC_ALL=C sort -u -o \u0026#34;$FROM_PKGS\u0026#34; \u0026#34;$FROM_PKGS\u0026#34; LC_ALL=C sort -u -o \u0026#34;$FROM_FS\u0026#34; \u0026#34;$FROM_FS\u0026#34; # see which paths in $FROM_FS are not in $FROM_PKGS LC_ALL=C join -a 2 -v 2 \u0026#34;$FROM_PKGS\u0026#34; \u0026#34;$FROM_FS\u0026#34; # clean up other two temp files rm \u0026#34;$FROM_FS\u0026#34; \u0026#34;$FROM_PKGS\u0026#34; The script will give us a list of orphans. We can compute the size they use on disk using that list.\nWe can further explore the results the script generated in the file orphans-size:\n show the top-ten orphan files by its disk usage:  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | sort -k 1 -n -u | tail -n 10 | sed \u0026#39;s/ \\//K \\//\u0026#39; | numfmt --from=si --to=si 96M /var/lib/flatpak/repo/objects/05/91c08407fbaa7dccc4cbc541865d27d4714b14d51417dc658841e3cd96d489.commitmeta 105M /usr/local/cuda-9.2/lib64/libcufft_static.a 115M /usr/local/cuda-9.2/nsightee_plugins/com.nvidia.cuda.repo-1.0.0-SNAPSHOT.zip 117M /usr/local/cuda-9.2/lib64/libcusolver.so.9.2.148 124M /var/lib/flatpak/app/com.spotify.Client/x86_64/stable/0591c08407fbaa7dccc4cbc541865d27d4714b14d51417dc658841e3cd96d489/files/extra/share/spotify/libcef.so 132M /var/tmp/elvis1.ses 177M /usr/local/cuda-9.2/lib64/libnvgraph_static.a 252M /var/lib/flatpak/repo/objects/69/74b95360b298f4cfe1be4025689ea20e918b689a5110984b3ffe7d339faf45.file 252M /var/lib/flatpak/repo/objects/df/45dafc31028c33ba2b26b08342dfe4044937e54eb9a3305c1cea28b5e9dfb5.file 330M /var/cache/sbopkg/qt-everywhere-opensource-src-5.7.1.tar.xz root@darkstar:/tmp/orphan.xvA0L1#   summary the size of an specific folder  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | grep \u0026#34;/usr/local/cuda-9.2*\u0026#34; | awk \u0026#39;{print $1}\u0026#39; | sort -n -k 1 | paste -sd+ | bc | sed \u0026#39;s/$/K/\u0026#39; | numfmt --from=si --to=si 2.9G root@darkstar:/tmp/orphan.xvA0L1#   summary to the second level directory hierarchy  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | cut -d \u0026#39;/\u0026#39; -f 1,2,3 | sort -n -k 1 -u | awk \u0026#39;{size[$2]+=$1}END{for (s in size){print size[s],\u0026#34; \u0026#34;, s}}\u0026#39; | sort -k1 -n | sed \u0026#39;s/ /K /\u0026#39; | numfmt --from=si --to=si | tail -n 10 88M /root/.cache 115M /usr/share 125M /root/NVIDIA_CUDA-9.2_Samples 138M /var/tmp 165M /opt/calibre 188M /usr/lib64 515M /var/cache 1.2G /root/latest 2.4G /var/lib 2.5G /usr/local root@darkstar:/tmp/orphan.xvA0L1# After all this work, isn\u0026rsquo;t there an application to work this out without arcane shell commands?\nDelete unwanted files After the analysis we\u0026rsquo;ve identified where the disk space is and what kind of files use them:\n /usr/local contains 2.5G of unaccounted space, used by cuda, plan9ports and go installations /var/lib contains 2.4G of unaccounted space, used by pacakge tools like SlackBuilds or Flatpak. /root cotains 1.2G of unaccounted space, used by cuda and other scripts  Also we identified packages we don\u0026rsquo;t use which use a lot of disk space like MariaDB, Rust, or TeX.\nWith that in mind we can free up a couple of GB easily without breaking anything on the system, just deleting the folders with rm.\n","summary":"\u003cp\u003eIn this post we will explore how to free disk space without reinstalling the system, and will present some scripts to help in the process.\u003c/p\u003e","tags":["slackbook"],"title":"Disk usage","url":"/web/posts/diskusage/"},{"categories":["technology"],"contents":" This document is a derivative of the Slacbook:install. The aim is to produce an evolution and contribute it back to the original work.\nIntroduction Package management is an essential part of any Linux distribution. The software included in Slackware, along with many third-party tools, is distributed as source code. But compiling all those thousands of different applications and libraries is tedious and time consuming. That\u0026rsquo;s why many people prefer to install pre-compiled software packages. In fact, when you installed Slackware, the setup program run the package management tools on a list of packages. Here we\u0026rsquo;ll look at the various tools used for handling Slackware packages.\nSlackware packages are tar files compressed by gzip or xz whose name contains the software name and version, the computer architecture of the included binaries and the package maintainer tag.\npackageName-version-arch-tag.txz\nThe package management tools use metadata stored in /var/log/packages to do their operations. This metadata is generated when the package is installed, and stored in files named after the package. In the next Slackware release the metadata will be stored in /var/lib/pkgtool.\npackage metadata file   You can see the installed packages on your system by listing the contents of /var/log/packages, and on each file you can explore the following metadata fields:\n Package name Compressed package size Uncompressed package size Package location Package description File list  Slackware packages were compressed with the gzip compression utility, which was a good compromise between compression speed and size. But new compression schemes have been added and today, official Slackware packages use the xz utility and end with .txz extensions. Older packages, and many third party packages, still use the .tgz extension.\nIt\u0026rsquo;s worth emphasizing that .tgz and .txz (or, more succinctly, .t?z files) are standard, non-unique extensions for compressed .tar files. This has many advantages; they\u0026rsquo;re easy to build on any UNIX system (many other package formats require special tools), and they\u0026rsquo;re just as simple to de-construct.\nHowever, it is also important to realize that just because all Slackware packages are .t?z files, not all .t?z files are Slackware packages. installpkg won\u0026rsquo;t install just any .t?z file, only Slackware packages.\nA package contains an install folder with scripts to execute in the install process. The documentation of `makepkg contains the details of the install scripts.\nSlackware package management tools do not automatically manage the package dependencies and there is no such information on the package metadata and are written in shell script.\nIn the next sections we describe the standard package management tools and mention non-standard ones for the advanced user.\npkgtool The way to perform package maintenance tasks is to invoke pkgtool, a menu-driven interface which allows you to install or remove packages and view the contents of those packages and the list of installed packages in a user-friendly ncurses interface.\npkgtool user interface   pkgtool is a convenient and easy way to perform the most basic tasks, but for more advanced work we need more flexible tools.\nInstalling, Removing, and Upgrading Packages While pkgtool scores points for convenience, `installpkg can handle odd tasks, such as installing a single package, installing an entire disk set of packages, or scripting an custom installation process.\ninstallpkg takes a list of packages to install and installs them asking no questions. Like all Slackware package management tools, it assumes that you know what you\u0026rsquo;re doing and doesn\u0026rsquo;t pretend to be smarter than you. In its simplest form, installpkg takes a list of packages to install, and does what you would expect.\npkgtool user interface   You can install multiple packages at a time, and in fact use shell wild cards.The following installs all the “N” series packages from a mounted CD-ROM:\ndarkstar:~# installpkg /mnt/cdrom/slackware/n/*.txz removepkg will check the contents of the package metadata file and will remove all the files and directories for that package with one caveat. It will not remove files used by multiple installed packages, or non-empty directories.\ndarkstar:~# removepkg blackbox-0.70.1-i486-2.txz``` upgradepkg which first installs a new package, then removes whatever files and directories are left-over from the old package. It doesn\u0026rsquo;t check if the installed package has a higher version number than the “new” package, so it can also downgrade a package to older versions.\ndarkstar:~# upgradepkg blackbox-0.70.1-i486-2.txz +============================================================================== | Upgrading blackbox-0.65.0-x86_64-4 package using ./blackbox-0.70.1-i486-2.txz +============================================================================== Pre-installing package blackbox-0.70.1-i486-2... Removing package /var/log/packages/blackbox-0.65.0-x86_64-4-upgraded-2010-02-23,16:50:51... --\u0026gt; Deleting symlink /usr/share/blackbox/nls/POSIX --\u0026gt; Deleting symlink /usr/share/blackbox/nls/US_ASCII --\u0026gt; Deleting symlink /usr/share/blackbox/nls/de --\u0026gt; Deleting symlink /usr/share/blackbox/nls/en --\u0026gt; Deleting symlink /usr/share/blackbox/nls/en_GB ... Package blackbox-0.65.0-x86_64-4 upgraded with new package ./blackbox-0.70.1-i486-2.txz. These tools have useful arguments. For example, the –root to installpkg will install packages into an arbitrary directory. The –dry-run argument will instruct upgradepkg to tell you what it would attempt without changing the system. For complete details, refer to the man pages.\nslackpkg Slackpkg is an automated tool for management of Slackware Linux Packages. It Appeared in /extra for the release of slackware-12.1, and since the release of slackware-12.2 they have included it in the ap/ series of a base installation.\nYou can find the latest version of slackpkg and its documentation at https://slackpkg.org.\nSlacpkg can download packages from a mirror in Internet and install them into your computer. This is useful for security updates or application upgrades.\nWithout slackpkg, the process would be:\n Notice in the Slackware change log they have released an update. Look on your local Slackware mirror to find a download link of the package. Download the package from a Slackware mirror to your hard drive. Use either installpkg or pkgtool to install the downloaded package.  Slackpkg reduces the process to:\n Notice in the Slackware change log they have released an update. slackpkg install or upgrade the changed package  To use slackpkg, configure your system with a Slackware mirror by editing /etc/slackpkg/mirrors as root user. Find a mirror with your Slackware version and architecture and enable it by deleting the # at the start of the line. Only one mirror can be enabled at a time.\nThen, update the local change log by issuing the command slackpkg update. This command will download the change log and will compare it with your local copy. If there are any differences, the local file is updated with the remote contents.\nYou should do this any time you notice they have posted a new package (check in with the Slackware change log once a day!).\nTo search for a package, use slackpkg search foo, and to install use slackpkg install foo.\nYou can manage the packages installed with slackpkg using pkgtool and the other standard package management commands.\nFor more information see the man pages for slackpkg(8) and slackpkg.conf(5), and see its website\nThere is also a novel tool called slackpkg+ which augments the current slackpkg tool to work with multiple repositories, for more information see its Guthub repository\nslackbuilds Original source: slackbuilds.org\nOne of the frequent criticisms of Slackware is the lack of official packages available. While the official package set provides a good, stable, and flexible operating system (and is quite adequate for many individuals), the fact remains that many users want/need quite a few additional applications in order for it to meet their needs.\nThere are a few well-known third party package repositories, but many users justifiably do not want to install untrusted packages on their systems. For those users, the traditional solution has been to download the source code for desired applications and compile them manually.\nThis works, but introduces another set of problems associated with managing those applications; version updates and such require more of the admin\u0026rsquo;s time than precompiled packages, and lack of notes will often mean that the admin forgot which configure flags were used earlier (as well as any other special issues encountered).\nIn our opinion, the best solution to this problem is for the admin to automate the compile process using a SlackBuild script. Patrick Volkerding, the maintainer of Slackware, uses SlackBuild scripts to compile the official packages, so it makes sense for us to use the same idea for extra applications we want to add.\nOur goal is to have the largest collection of SlackBuild scripts available while still ensuring that they are of the highest quality - we test every submission prior to inclusion in the repository. We do not now nor will we ever provide precompiled packages for any of the applications for which we have SlackBuild scripts - instead, we want the system administrator (that\u0026rsquo;s you) to be responsible for building the packages.\nHow to use it can be read in their fantastic documentation at their website\nBuilding a package Original source: slack how-to\nConfigure and compile the source as you usually do:\n./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc make Make a temporary destination directory available:\nmkdir /tmp/build Install into the temporary directory:\nmake install DESTDIR=/tmp/build Now strip libs/bins within the temporary directory:\nstrip -s /tmp/build/usr/lib/* /tmp/build/usr/bin/* You also want to make sure that anything in /usr/man is gzipped before you make the package:\ngzip -9 /tmp/build/usr/man/man?/*.? Create the install directory, this is where the description and install script will be stored:\ncd /tmp/build mkdir install cd install One-liner (for the copy \u0026amp; paste people):\ncd /tmp/build; mkdir install; cd install Using a text editor (or a tool), create a file called slack-desc and fill it with the following contents:\nappname: appname (Short description of the application) appname: \u0026lt;this line is generally left blank\u0026gt; appname: Description of application - this description should be fairly appname: in-depth; in other words, make it clear what the package does (and appname: maybe include relevant links and/or instructions if there\u0026#39;s room), appname: but don\u0026#39;t get too verbose. appname: This file can have a maximum of eleven (11) lines of text preceded by appname: the \u0026#34;appname: \u0026#34; designation. appname: appname: It\u0026#39;s a good idea to include a link to the application\u0026#39;s homepage too. appname: The “appname” string must exactly match the application name portion of the Slackware package (for example, a package titled “gaim-1.5-i486-1.tgz” must have a slack-desc file with the  string of “gaim: ” rather than “Gaim: ” or “GAIM: ” or something else.\nThe first line must show the application name followed by a short description (enclosed in parentheses).\nCreate the actual package:\ncd /tmp/build makepkg ../app-version-arch-tag.tgz (The dashes should appear as above, so if the version has a subversion like say “1.0 RC2” make sure you use 1.0_RC2 not 1.0-RC2. The arch should be something like “i486” for example. The tag should consist of the build number and your initals, e.g. 1zb for Zaphod Beeblebrox\u0026rsquo;s first build, 2zb for his second build, etc. Official slackware packages have only numbers as tags.)\n When prompted to recreate symbolic links, say yes When prompted to reset permissions, say no  Note: Using makepkg -l y -c n will give you the same behaviour as answering yes to the symlinks question, and no to the permissions question.\nIf all went well, you can now install the package.\ncd .. installpkg app-version-arch-tag.tgz ","summary":"This document is a derivative of the Slacbook:install. The aim is to produce an evolution and contribute it back to the original work.\nIntroduction Package management is an essential part of any Linux distribution. The software included in Slackware, along with many third-party tools, is distributed as source code. But compiling all those thousands of different applications and libraries is tedious and time consuming. That\u0026rsquo;s why many people prefer to install pre-compiled software packages.","tags":["packages","slackbuild","pkgtool","installpkg","slackpkg","slackpkg+","how-to"],"title":"Package Management","url":"/web/docs/packages/"},{"categories":["documentation"],"contents":"From it\u0026rsquo;s manual page xterm(1):\nThe xterm program is a terminal emulator for the X Window System. It provides DEC VT102/VT220 and selected features from higher-level terminals such as VT320/VT420/VT520 (VTxxx). It also provides Tektronix 4014 emulation for programs that cannot use the window system directly.If the underlying operating system supports terminal resizing capabilities (for example, the SIGWINCH signal in systems derived from 4.3BSD), xterm will use the facilities to notify programs running in the window whenever it is resized.\nIt\u0026rsquo;s currently maintained and the changes can be followed in Thomas E. Dickey site\nFeatures and configuration It\u0026rsquo;s reason to be, emulation of other terminals, should be considered on my opinion it\u0026rsquo;s major feature. It provides emulation for a lot of old terminals, so that software written long ago can be used on today systems, emulating the screens those computers had. XTerm still provides a fairly complete emulation of those terminals. See for example these Tektronix programs.\nFonts It can be condifured to use fonts supported by the FreeType library, which is pretty much any font you can find out there (TTF, OTF, etc.) It can only have one font size per session, so any given XTerm window will have the same font size on all the text buffer. But the size of the current font can be changed to multiple options (tiny, small, medium, huge, default) using the fonts menu (CTRL+3rd mouse button click).\nXterm showing the contents of an .Xresources file   The font management in X is a bit messy, but you can have decent results with a bit of work.\nUnicode Xterm is able to show unicode characters. There is an xterm wrapper uxterm which set up xterm to show them,as it not show them by default. But it does not work well with all the fonts. In case you need non latin output, I suggest you to use uterm wrapper and the default fonts. Unless you need it to do heavy work that you will need to search for a good font for your needs.\nXterm with htop application running   Note that this terminal font is rendered in your browser and might have better Unicode support. Below is an image of what appeared on the screen:\n Xterm screenshot of Unicode test    ncurses Xterm has the best support for ncurses programs AFAICT. It might me related to the fact that Thomas E. Dickey is related to both xterm and also ncruses.\nxhtml export It has the feature to export the current window, not the whole buffer as an XHTML page. The terminals on this site have been generated using that functionality. Colors and ncurses are supported and the final result is quite good.\nXterm with calcurses application running   Xterm with htop application running   Note that the screen captures uses the default monospace font from your browser. I\u0026rsquo;m using Terminus (TTF) font as the monospace font in my browsers and the render of both consoles are just like I saw them in the Xterm.\nUsability It\u0026rsquo;s menu system, the .Xresources file, and the config modifications you can apply without closing and restarting the session is a bit annoying. But the work I normally do in XTerm does not requiere such things.\nYou can serach using a printerCommand, like the one in the screenshot of my .Xresources file, but it would be nice if you could just do that in the current buffer\nPerformance I do not require a special performance of a terminal emulator. Also I have plenty of memory to run an XTerm from time to time.\nBugs The XTerm is famous for its difficult code, its bugs, and its complexity:\n cut/paste does not select tabs; instead spaces are selected. This is because the selection works from the array of displayed characters, on which tab/space conversion has already been performed. does not implement the autorepeat feature of VTxxx terminals. the program must be run with fixed (nonproportional) fonts. the home and end keys do not generate usable escape sequences, due to an indexing error. the Main Options menu is improperly constructed, due to incorrect indices after removing the logging toggle. This makes the list of signals off by one. very large screens (e.g., by using nil2 for a font) cause core dumps because the program uses a fixed array (200 lines) for adjusting pointers. certain types of key translations cause a core dump because the program does not check the event class before attempting to use events. ","summary":"\u003cp\u003eFrom it\u0026rsquo;s manual page xterm(1):\u003c/p\u003e\n\n\u003cp\u003eThe xterm program is a terminal emulator for the X Window System.  It provides DEC VT102/VT220 and selected features from higher-level terminals such as VT320/VT420/VT520 (VTxxx). It also provides Tektronix 4014 emulation for programs that cannot use the window system directly.If the underlying operating system supports terminal resizing capabilities (for example, the SIGWINCH signal in systems derived from 4.3BSD), xterm will use the facilities to notify programs running in the window whenever it is resized.\u003c/p\u003e","tags":["xterm"],"title":"The Xterm","url":"/web/posts/xterm/"},{"categories":["downloads"],"contents":"    {{if and (eq .Sort \"name\") (ne .Order \"desc\")}} Name \u0026#9650; {{else if and (eq .Sort \"name\") (ne .Order \"asc\")}} Name \u0026#9660; {{else}} Name {{end}}  {{if and (eq .Sort \"size\") (ne .Order \"desc\")}} Size \u0026#9650; {{else if and (eq .Sort \"size\") (ne .Order \"asc\")}} Size \u0026#9660; {{else}} Size {{end}}  {{if and (eq .Sort \"time\") (ne .Order \"desc\")}} Modified \u0026#9650; {{else if and (eq .Sort \"time\") (ne .Order \"asc\")}} Modified \u0026#9660; {{else}} Modified {{end}}   {{if .CanGoUp}}      ..     {{end}} {{range .Items}}  {{if .IsDir}} {{else}}{{end}}   {{.Name}}  {{if not .IsDir}}{{.HumanSize}}{{end}} {{.HumanModTime \"02.01.2006 15:04:05\"}}  {{end}}  ","summary":"{{if and (eq .Sort \"name\") (ne .Order \"desc\")}} Name \u0026#9650; {{else if and (eq .Sort \"name\") (ne .Order \"asc\")}} Name \u0026#9660; {{else}} Name {{end}}  {{if and (eq .Sort \"size\") (ne .Order \"desc\")}} Size \u0026#9650; {{else if and (eq .Sort \"size\") (ne .Order \"asc\")}} Size \u0026#9660; {{else}} Size {{end}}  {{if and (eq .Sort \"time\") (ne .Order \"desc\")}} Modified \u0026#9650; {{else if and (eq .Sort \"time\") (ne .","tags":["packages","images"],"title":"Downloads","url":"/web/downloads/downloads/"},{"categories":["technology"],"contents":" In this article we\u0026rsquo;re going to describe how to build your own slackware distribution based on the official disitribution.\nTo do that we will describe the process of generating a slackware image to use in cloud environments.\nPrepare the environment We\u0026rsquo;re going to use the repository https://github.com/slacware-es/dev to upload all the scripts needed to build your own slackware distribution.\nSelect your packages Generate tag files Build installation media Install / distribute ","summary":" In this article we\u0026rsquo;re going to describe how to build your own slackware distribution based on the official disitribution.\nTo do that we will describe the process of generating a slackware image to use in cloud environments.\nPrepare the environment We\u0026rsquo;re going to use the repository https://github.com/slacware-es/dev to upload all the scripts needed to build your own slackware distribution.\nSelect your packages Generate tag files Build installation media Install / distribute ","tags":["build","how-to"],"title":"How to build your own Slackware","url":"/web/docs/build/"},{"categories":["technology"],"contents":" This document is a derivative of the Slacbook:install and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.\nIntroduction Slackware\u0026rsquo;s installation is a bit more simplistic than that of most other Linux distributions and is very reminiscent of installing one of the varieties of BSD operating systems. If you\u0026rsquo;re familiar with those, you should feel right at home. If you\u0026rsquo;ve never installed Slackware or used a distribution that makes use of a non-graphical installer, you may feel a bit overwhelmed at first. Don\u0026rsquo;t panic! The installation is very easy once you understand it, and it works on just about any x86 platform.\nThe latest versions of Slackware Linux are distributed on DVD or CD media, but Slackware can be installed in a variety of other ways. We\u0026rsquo;re only going to focus on the most common method - booting from a DVD - in this book. If you don\u0026rsquo;t have a CD or DVD drive, you might wish to take a look at the various README files inside the usb-and-pxe-installers directory at your favorite Slackware mirror. This directory includes the necessary files and instructions for booting the Slackware installer from a USB flash drive or from a network card that supports PXE. The files there are the best source of information available for such boot methods.\nStarting with the 14.1 release, Slackware ISO images (both the ones available online as well as the discs sent out from the Slackware store) have been processed using isohybrid. This allows them to be written to a USB stick, which can then be booted and used as the install source.\nA HOWTO on setting up a PXE boot server right off a Slackware installation medium (DVD or USB Stick) is available in this separate article: Out of the box Slackware PXE Server\nBooting Booting the installer is simply a process of inserting the Slackware install disk into your CD or DVD drive and rebooting. You may have to enter your computer\u0026rsquo;s BIOS and alter the boot order to place the optical drive at a higher boot priority than your hard drives. Some computers allow you to change the boot order on the fly by pressing a specific function key during system boot-up. Since every computer is different, we can\u0026rsquo;t offer instructions on how to do this, but the method is simple on nearly all machines.\nOnce your computer boots from the CD you\u0026rsquo;ll be taken to a screen that allows you to enter any special kernel parameters. This is here primarily to allow you to use the installer as a sort of rescue disk. Some systems may need special kernel parameters in order to boot, but these are very rare exceptions to the norm. Most users can simply press enter to let the kernel boot.\nBoot message   You should see a lot of text go flying across your screen. Don\u0026rsquo;t be alarmed, this is all perfectly normal. The text you see is generated by the kernel during boot-up as it discovers your hardware and prepares to load the operating system (in this case, the installer). You can later read these messages with the dmesg(1) command if you\u0026rsquo;re interested. Often these messages are very important for troubleshooting any hardware problems you may have. Once the kernel has completed its hardware discovery, the messages should stop and you\u0026rsquo;ll be given an option to load support for non-us keyboards.\nKeyboard option pre setup   Entering 1 and pressing ENTER will give you a list of keyboard mappings. Simply select the mapping that matches your keyboard type and continue on.\nKeyboard selection pre setup   Unlike other Linux distributions which boot you directly into a dedicated installer program, Slackware\u0026rsquo;s installer drops you into a limited Linux distribution loaded into your system\u0026rsquo;s RAM. This limited distribution is then used to run all the installation programs manually, or can be used in emergencies to fix a broken system that fails to boot. Now that you\u0026rsquo;re logged in as root (there is no password within the installer) it\u0026rsquo;s time to start setting up your disks. At this point, you may setup software RAID or LVM support if you wish or even an encrypted root partition, but those topics are outside of the scope of this book. I encourage you to refer to the excellent README_RAID.TXT, README_LVM.TXT, and README_CRYPT.TXT files on your CD if you desire to setup your system with these advanced tools. Most users won\u0026rsquo;t have any need to do so and should proceed directly to partitioning.\nPartitioning The Slackware installation media comes with tools to partition a hard drive. Usually partitioning a hard disk process is composed of these steps:\n Identify computer disks Running the desired partitioning tool on the target HDD. Showing the current partition table to see if there are any installed partitions. If needed, deleting partitions. Create a new partition. Selecting the type and size of the new partition. Continuing to create partitions as planned. Changing types of the partition (Swap, Linux, Solaris, etc). Setting a bootable flag to a desired partition. Writing the partition table.  How to select which hard drive you want to install on could be a challenge on some machines. A modern desktop or laptop can have multiple devices with different naming.\nTo list the disks present on a device we can list which devies have been recognized by the kernel like:\nIdentify computer disks   Or on a more complex scenario:\nIdentify computer disks complex   If the IDs of the decies doest tell you anything, you might want to search for them to identify which disk it might be,\nIn the comples scenario we can see multiple NVME devices described by their brand and model number.\nIn this simple scenario (the first one), we select the /dev/sda device and execute the cfdisk program like cfdisk /dev/sda. Then, its UI appears:\nCheck free space on disk   We need to create a partition on the hard disk to contain our Slackware system. We can see our disk is empty and we can use that empty space to create a new partition. If there is no free space on your disk, the first step is to create free space by deleting used space. This is a dangerous operation, so be sure you don\u0026rsquo;t need anything from that disk before deleting partitions.\ncfdisk will ask how much of that free space we want to assign to a partition when we select the option [New] and press enter.\nSelect partition size   If we plan to install the system boot loader in the boot sector of the partition, we need to mark it as bootable with the correspondent cfdisk menu. When its marked as bootable a * symbols appears under the Boot column.\nMark partition as bootable   In some situations we might need to create partitions of differnt types, for that we can change a partition type with the [Type] entry of the cfdisk program. We can select more than enought partition types.\nChange partition type   We everything is done, and we\u0026rsquo;re satisfied with the disk partitioning, we need to write the changes to the disk, and exit the program using the [Quit] menu.\nWrite partition and exit   The Setup Program Now that you\u0026rsquo;ve created your partitions it\u0026rsquo;s time to run the setup program to install Slackware. setup will handle formatting partitions, installing packages, and running basic configuration scripts step-by-step. In order to do so, just type setup at your shell prompt.\nWrite partition and exit   Help If you\u0026rsquo;ve never installed Slackware before, you can get a very basic over-view of the Slackware installer by reading the Help menu. Most of the information here is on navigating through the installer which should be fairly intuitive, but if you\u0026rsquo;ve never used a curses-based program before you may find this useful.\nAccess setup program help   Keymap Before we go any further, Slackware gives you the opportunity to select a different mapping for your keyboard. If you\u0026rsquo;re using a standard US keyboard you can safely skip this step, but if you\u0026rsquo;re using an international keyboard you will want to select the correct mapping now. This ensures that the keys you press on your keyboard will do exactly what you expect them to do\nSelect keymap   Addswap If you created a swap partition, this step will allow you to enable it before running any memory-intensive activities like installing packages. swap space is essentially virtual memory. It\u0026rsquo;s a hard drive partition (or a file, though Slackware\u0026rsquo;s installer does not support swap files) where regions of active system memory get copied when your computer is out of useable RAM. This lets the computer “swap” programs in and out of active RAM, allowing you to use more memory than your computer actually has. This step will also add your swap partition to /etc/fstab so it will be available to your OS.\nTarget Our next step is selecting our root partition and any other partitions we\u0026rsquo;d like Slackware to utilize. You\u0026rsquo;ll be given a choice of filesystems to use and whether or not to format the partition. If you\u0026rsquo;re installing to a new partition you must format it. If you have a partition with data on it you\u0026rsquo;d like to save, don\u0026rsquo;t. For example, many users have a seperate /home partition used for user data and elect not to format it on install. This lets them install newer versions of Slackware without having to backup and restore this data.\nSelect target partition   Source Here you\u0026rsquo;ll tell the installer where to find the Slackware packages. The most common method is to use the Slackware install DVD or CDs, but various other options are available. If you have your packages installed to a partition that you setup in the previous step, you can install from that partition or a pre-mounted directory. (You may need to mount that partition with mount(8) first. See chapter 11 for more details.) Additionally, Slackware offers a variety of networked options such as NFS shares, FTP, HTTP, and Samba. If you select a network installation, Slackware will prompt you for TCP/IP information first. We\u0026rsquo;re only going to discuss installation from the DVD, but other methods are similar and straightforward.\nSelect source media   Select One unique feature of Slackware is its manner of dividing packages into disksets. At the beginning of time, network access to FTP servers was available only through incredibly slow 300 baud modems, so Slackware was split into disk sets that would fit onto floppy disks so users could download and install only those packages they were interested in. Today that practice continues and the installer allows you to chose which sets to install. This allows you to easily skip packages you may not want, such as X and KDE on headless servers or Emacs on everything. Please note that the “A” series is always required.\nSelect source media   Install Finally we get to the meat of the installer. At this stage, Slackware will ask you what method to use to chose packages. If this is your first time installing Slackware, the “full” method is highly recommended. Even if this isn\u0026rsquo;t your first time, you\u0026rsquo;ll probably want to use it anyway.\nThe “menu” and “expert” options allow you to choose individual packages to install and are of use to skilled users familiar with the OS. These methods allow such users to quickly prune packages from the installer to build a very minimal system. If you don\u0026rsquo;t know what you\u0026rsquo;re doing (sometimes even if you do) you\u0026rsquo;re likely to leave out crucial pieces of software and end up with a broken system.\nThe “newbie” method can be very helpful to a new user, but takes a very long time to install. This method will install all the required packages, then prompt you individually for every other package. The big advantage here is that is pauses and gives you a brief overview of the package contents. For a new user, this introduction into what is included with Slackware can be informative. For most other users it is a long and tedious process.\nThe “custom” and “tagpath” options should only be used by people with the greatest skill and expertise with Slackware. These methods allow the user to install packages from custom tagfiles. Tagfiles are only rarely used. We won\u0026rsquo;t discuss them in this book.\nSelect source media   If we select the recommended prompt mode we will see how the program install all selected series of packages and shows information for each package. It could be too fast to read in modern computers.\nInstalling packages   Configure Once all the packages are installed you\u0026rsquo;re nearly finished. At this stage, Slackware will prompt you with a variety of configuration tasks for your new operating system. Many of these are optional, but most users will need to set something up here. Depending on the packages you\u0026rsquo;ve installed, you may be offered different configuration options than the ones shown here, but we\u0026rsquo;ve included all the really important ones.\nUSB boot disk The first thing you\u0026rsquo;ll likely be prompted to do is setup a boot disk. In the past this was typically a 1.44MB floppy disk, but today\u0026rsquo;s Linux kernel is far too large to fit on a single floppy, so Slackware offers to create a bootable USB flash memory stick. Of course, your computer must support booting from USB in order to use a USB boot stick (most modern computers do). If you do not intend to use LILO or another traditional boot loader, you should consider making a USB boot stick. Please note that doing so will erase the contents of whatever memory stick you\u0026rsquo;re using, so be careful.\nMake bootable USB   LILO: The Linux Loader Nearly everyone will need to setup the LInux LOader, LILO. LILO is in charge of booting the Linux kernel and connecting to an initrd or the root filesystem. Without it (or some other boot loader), your new Slackware operating system will not boot. Slackware offers a few options here. The “simple” method attempts to automatically configure LILO for your computer, and works well with very simple systems. If Slackware is the only operating system on your computer, it should configure and install LILO for you without any hassels. If you don\u0026rsquo;t trust the simpler method to work, or if you want to take an in-depth look at how to configure LILO, the “expert” method is really not all that complicated. This method will take you through each step and offer to setup dual-boot for Windows and other Linux operating systems. It also allows you to append kernel command parameters (most users will not need to specify any though).\nMake bootable USB   On modern UEFI machines and on some virtualization environment LILO might not work, and you might need to install GRUB or boot directly the linux kernel from the UEFI partition.\nMouse: enable gpm This simple step allows you to configure and activate a console mouse for use outside of the graphical desktops. By activating a console mouse, you\u0026rsquo;ll be able to easily copy and paste from within the Slackware terminal. Most users will need to choose one of the first three options, but many are offered, and yes those ancient two-button serial mice do work.\nSelect mouse type   And then enable the gpm to enable mouse on the console at boot time.\nSelect mouse type   Network configuration If you don\u0026rsquo;t wish to configure your network at this stage, you may decline, but otherwise you\u0026rsquo;ll be prompted to provide a hostname for your computer.\nFor laptops and desktop computing (development workstation, family PC, etc.) you will need a Network Manager setup. For a server you might need something different. In this scenario we\u0026rsquo;re going to cover the laptop/home computing scenario.\nFirst, select we want to setup the network now:\nConfirm we want to setup our network   Enter a host name to describe your computer. You might need to type it often for other configurations, so choose wisely (only letters and numbers allowed).\nEnter a host name   Enter a domain name. This is not used on home computer environmnent most of the time, so almost always can invent a domain name to put here like slackware.com.\nEnter a domain name   Select the Network Manager option:\nSelect network manager   Then confirm the data we\u0026rsquo;ve entered is correct to continue the set up.\nConfirm network set up   Start up services Once your network configuration is completed Slackware will prompt you to configure the startup services that you wish to run automatically upon boot. Helpful descriptions of each service appear both to the right of the service name as well as at the bottom of the screen. If you\u0026rsquo;re not sure what to turn on, you can safely leave the defaults in place. What services are started at boot time can be easily modified later with pkgtool.\nThe default ones are normally fine, but you might want to enable or disable some. The fewer you need the better normally.\nEnable start up services   Time zone Every computer needs to keep track of the current time, and with so many timezones around the world you have to tell Slackware which one to use. If your computer\u0026rsquo;s hardware clock is set to UTC (Coordinated Universal Time), you\u0026rsquo;ll need to select that; most hardware clocks are not set to UTC from the factory (though you could set it that way on your own; Slackware doesn\u0026rsquo;t care). Then simply select your timezone from the list provided and off you go.\nIF you have another OS like Microsoft Windows installed on your computer, your hardware clock would be set up to you local time. If you\u0026rsquo;re going to use Slackware as your system, you can choose the option you like more.\nSetup hardware clock   If you selected that your hardware clock is sync\u0026rsquo;ed to UTC the timezone selection will show your local time and date correctly. In any case, the timezone is also needed when the clock is sync\u0026rsquo;ed to local time.\nSet yout local timezone   Window manager If you installed the X disk set, you\u0026rsquo;ll be prompted to select a default window manager or desktop environment. What you select here will apply to every user on your computer, unless that user decides to run xwmconfig(1) and choose a different one. Don\u0026rsquo;t be alarmed if the options you see below do not match the ones Slackware offers you. xwmconfig only offers choices that you installed. So for example, if you elected to skip the “KDE” disk set, KDE will not be offered.\nSelect your window manager   Root password he last configuration step is setting a root password. The root user is the “super user” on Slackware and all other UNIX-like operating systems. Think of root as the Administrator user. root knows all, sees all, and can do all, so setting a strong root password is just common sense.\nSet the root password   Additional settings and reboot At this point Slackware is installed. If you need to do additional operations before rebooting, select the appropriate options in the following steps:\nRemove installation media   Reboot?   Remove the Slackware installation disk, and if you performed all the steps correctly, your computer will boot into your new Slackware linux system. If something went wrong, you probably skipped the LILO configuration step or made an error there somehow.\nOr be prepared to do your stuff in an screen like this before rebooting ☺\nReboot?   ","summary":"This document is a derivative of the Slacbook:install and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.\nIntroduction Slackware\u0026rsquo;s installation is a bit more simplistic than that of most other Linux distributions and is very reminiscent of installing one of the varieties of BSD operating systems. If you\u0026rsquo;re familiar with those, you should feel right at home. If you\u0026rsquo;ve never installed Slackware or used a distribution that makes use of a non-graphical installer, you may feel a bit overwhelmed at first.","tags":["install","how-to","setup"],"title":"Slackware installation","url":"/web/docs/install/"},{"categories":["documentation"],"contents":"The Slackware Book can be read online in its original form at: slackbook.\nI\u0026rsquo;ll reproduce here the introduction paragraphs. Please consider to collaborate with the Slackware documentation project in it\u0026rsquo;s web site\nWhy Use Slackware? Slackware has a long tradition of excellence. Started in 1992 and first released in 1993, Slackware is the oldest surviving commercial Linux distribution. Slackware\u0026rsquo;s focus on making a clean, simple Linux distribution that is as UNIX-like as possible makes it a natural choice for those people who really want to learn about Linux and other UNIX-like operating systems. In a 2012 interview, Slackware founder and benevolent dictator for life, Patrick Volkerding, put it thusly.\n\u0026ldquo;I try not to let things get juggled around simply for the sake of making them different. People who come back to Slackware after a time tend to be pleasantly surprised that they don\u0026rsquo;t need to relearn how to do everything. This has given us quite a loyal following, for which I am grateful.\u0026rdquo;\nSlackware\u0026rsquo;s simplicity makes it ideal for those users who want to create their own custom systems. Of course, Slackware is great in its own right as a desktop, workstation, or server as well.\nDifferences Compared to Other Linux Distributions There are a great number of differences between Slackware and other mainstream distributions such as Red Hat, Debian, and Ubuntu. Perhaps the greatest difference is the lack of \u0026ldquo;hand-holding\u0026rdquo; that Slackware will do for the administrator. Many of those other distributions ship with custom graphical configuration tools for all manner of services. In many cases, these configuration tools are the preferred method of setting up applications on these systems and will overwrite any changes you make to the configuration files via other means. These tools often make it easy (or at least possible) for a rookie with no in-depth understanding of his system to setup basic services; however, they also make it difficult to do anything too out of the ordinary. In contrast, Slackware expects you, the system administrator, to do these tasks on your own. Slackware provides no general purpose setup tools beyond those included with the source code published by upstream developers. This means there is often a somewhat steeper learning curve associated with Slackware, even for those users familiar with other Linux distributions, but also makes it much easier to do whatever you want with your operating system.\nAlso, you may hear users of other distributions say that Slackware has no package management system. This is completely and obviously false. Slackware has always had package management (see Chapter 17, Package Management for more information). What it does not have is automatic dependency resolution - Slackware\u0026rsquo;s package tools trade dependency management for simplicity, ease-of-use, and reliability.\nLicensing Each piece of Slackware (this is true of all Linux distributions) is developed by different people (or teams of people), and each group has their own ideas about what it means to be \u0026ldquo;free\u0026rdquo;. Because of this, there are literally dozens and dozens of different licenses granting you different permissions regarding their use or distribution. Fortunately dealing with free software licenses isn\u0026rsquo;t as difficult as it may first appear. Most things are licensed with either the Gnu General Public License or the BSD license. Sometimes you\u0026rsquo;ll encounter a piece of software with a different license, but in almost all cases they are remarkably similar to either the GPL or the BSD license.\nProbably the most popular license in use within the Free Software community is the GNU General Public License. The GPL was created by the Free Software Foundation, which actively works to create and distribute software that guarantees the freedoms which they believe are basic rights. In fact, this is the very group that coined the term \u0026ldquo;Free Software.\u0026rdquo; The GPL imposes no restrictions on the use of software. In fact, you don\u0026rsquo;t even have to accept the terms of the license in order to use the software, but you are not allowed to redistribute the software or any changes to it without abiding by the terms of the license agreement. A large number of software projects shipped with Slackware, from the Linux kernel itself to the Samba project, are released under the terms of the GPL.\nAnother very common license is the BSD license, which is arguably \u0026ldquo;more free\u0026rdquo; than the GPL because it imposes virtually no restrictions on derivative works. The BSD license simply requires that the copyright remain intact along with a simple disclaimer. Many of the utilities specific to Slackware are licensed with a BSD-style license, and this is the preferred license for many smaller projects and tools.\n","summary":"\u003cp\u003eThe Slackware Book can be read online in its original form at: \u003ca href=\"https://slackbook.org/beta/\"\u003eslackbook\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eI\u0026rsquo;ll reproduce here the introduction paragraphs. Please consider to collaborate with the Slackware documentation project in \u003ca href=\"https://docs.slackware.com\"\u003eit\u0026rsquo;s web site\u003c/a\u003e\u003c/p\u003e","tags":["slackbook"],"title":"The Slackware Book","url":"/web/posts/slackbook/"}]