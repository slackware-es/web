<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>Documentation on Slackware</title>
    <link>/web/categories/documentation/</link>
    <description>Recent content in Documentation on Slackware</description>
    <image>
      <title>Documentation on Slackware</title>
      <link>/web/categories/documentation/</link>
      <url>/web/img/penguins.jpg</url>
    </image>
    <ttl>1440</ttl>
    <generator>Hugo 0.53</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 01 Sep 2018 06:00:00 +0000</lastBuildDate>
    
      <atom:link href="/web/categories/documentation/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>Sysstat: an easy status page</title>
        <link>/web/posts/statuspage/</link>
        <pubDate>Sat, 01 Sep 2018 06:00:00 +0000</pubDate>
        <guid>/web/posts/statuspage/</guid>
        <description>Introduction   The ```sysstat``` package contains various utilities, common to many commercial Unixes, to monitor system performance and usage activity. http://sebastien.godard.pagesperso-orange.fr/  sysstat is a standard package which comes with Slackware distribution and almost any other distribution out there. Its a very useful tool to analize and monitor linux performance.
We are going to build a simple status page which will display performance metrics about the linux systems it runs on, including usage of:</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[ Introduction   The ```sysstat``` package contains various utilities, common to many commercial Unixes, to monitor system performance and usage activity. http://sebastien.godard.pagesperso-orange.fr/  sysstat is a standard package which comes with Slackware distribution and almost any other distribution out there. Its a very useful tool to analize and monitor linux performance.
We are going to build a simple status page which will display performance metrics about the linux systems it runs on, including usage of:
 CPU Memory Network Disk  And also process based statistics such system load and process queue.
We want something simple, but sysstat tools are powerfull enough to build much more complex systems.
Install sysstat package sysstat package comes preinstalled in a full installation of Slackware, but if you&amp;rsquo;re using a custom package setup, please check you have sysstat and lm_sensors packages.
Monitoring We want to calculate statistics in 10 minute periods with one measurement each minute. So we use the sa1 tool to record all collectable data in periods of 600 seconds with collection every 60 seconds. Also we want to repeat this process constantly so we create a cron job to automate the execution.
This tool will save in the file `/var/log/sa/saDD the data collected and will change DD accordinly to the they of the month.
# monitoring 0,10,20,30,40,50 * * * * /usr/lib64/sa/sa1 -S XALL 600 60 Then we want to generate some graphics to read the data and store them in a location accesible by our webserver. We want to update our status page as soon as the data has been collected. Using the sadf tools we generate an SVG image containg all the graphs we need:
 CPU: -u Memory: -r Network: -n DEV Disk: -d System Load: -p Process queue: -q  So we add another cronjob, to execute after the other one. Also we save the results of the svg generation in the file /var/www/sar/stats.svg. This directory needs to be configured in our webserverto make it available externally. It is also possible to download the file using ssh to view it locally if we do not have a web service in the system.
1,11,21,31,41,51 * * * * /usr/bin/sadf -g -- -u -p -q -r -d -n DEV &amp;gt; /var/www/sar/stats.svg The status page In order to view the generated SVG easily in a browser of mobile, we generate an HTML template as follows:
&amp;lt;!doctype html&amp;gt; &amp;lt;html class=&amp;#34;no-js&amp;#34; lang=&amp;#34;&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34;&amp;gt; &amp;lt;meta http-equiv=&amp;#34;x-ua-compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34;&amp;gt; &amp;lt;title&amp;gt;Linux Sysstat Page&amp;lt;/title&amp;gt; &amp;lt;meta name=&amp;#34;description&amp;#34; content=&amp;#34;&amp;#34;&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1, shrink-to-fit=no&amp;#34;&amp;gt; &amp;lt;style&amp;gt; .svg-container { display: inline-block; vertical-align: middle; } .svg-content { display: inline-block; top: 0; left: 0; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!--[if lte IE 9]&amp;gt; &amp;lt;p class=&amp;#34;browserupgrade&amp;#34;&amp;gt;You are using an &amp;lt;strong&amp;gt;outdated&amp;lt;/strong&amp;gt; browser. Please &amp;lt;a href=&amp;#34;https://browsehappy.com/&amp;#34;&amp;gt;upgrade your browser&amp;lt;/a&amp;gt; t o improve your experience and security.&amp;lt;/p&amp;gt; &amp;lt;![endif]--&amp;gt; &amp;lt;div class=&amp;#34;svg-container&amp;#34;&amp;gt; &amp;lt;object type=&amp;#34;image/svg&#43;xml&amp;#34; data=&amp;#34;stats.svg&amp;#34; width=&amp;#34;1024px&amp;#34; height=&amp;#34;9000px&amp;#34; class=&amp;#34;svg-content&amp;#34;&amp;gt; &amp;lt;/object&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;  And save it as /var/www/sar/index.html.
The size specified in the SVG object was generated taking into account our output from the sadf tool. It might change if your options change, so update it accordingly.
Resources  Demo Home page systsat tutorial  ]]></content:encoded>
      </item>
    
      <item>
        <title>PostgREST: BAAS for PostgreSQL databases</title>
        <link>/web/posts/postgrest/</link>
        <pubDate>Wed, 29 Aug 2018 06:00:00 +0000</pubDate>
        <guid>/web/posts/postgrest/</guid>
        <description>Introduction   PostgREST is a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations. Using PostgREST is an alternative to manual CRUD programming. Custom API servers suffer problems. Writing business logic often duplicates, ignores or hobbles database structure. Object-relational mapping is a leaky abstraction leading to slow imperative code. The PostgREST philosophy establishes a single declarative source of truth: the data itself.</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[ Introduction   PostgREST is a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations. Using PostgREST is an alternative to manual CRUD programming. Custom API servers suffer problems. Writing business logic often duplicates, ignores or hobbles database structure. Object-relational mapping is a leaky abstraction leading to slow imperative code. The PostgREST philosophy establishes a single declarative source of truth: the data itself. https://postgrest.org/en/v5.0/intro.html  Our aim is to build and experiment with applications using an HTTP based back-end. These applications can use a lot of languages and environments: shell scripts, Javascript, etc.
Building a package for Slackware PostgREST is written in the Haskell programming language, so to build the software we need a Haskell compiler installed into our build system. We can install the Glasgow Haskell Compiler from the SlackBuild repository. The official build instructions are basically to execute the command:
# stack build --install-ghc --copy-bins --local-bin-path /usr/local/bin With this information, we can build our own SlackBuild script. Look into our repository to see all the files.
Build the PostgREST package executing the postgrest.SlackBuild script. It will generate the package into /tmp.
Once you have the package, we need to install it into the server.
Before setting up This package requires a working PostgreSQL database, configured with user access, tables, etc. The service requires planning carefully the database schemas, permissions and functions to work.
Try to set up first an SQL program to build your database before setting up PostgREST. Also, follow the tutorials and the documentation in their website.
We had problems with schema isolation. We learned that we need to set up the search_path per function.
It is also advisable to split the internal procedures, and the external ones, so only the API only exposes what it is really neeed and nothing more.
Setting PostgREST up Before starting, PostREST needs a configuration file describing the environment. The package expects the configuration file to be /opt/postgrest/etc/postgrest.conf. The configuration file documentation details how to set up PostgREST. It will neeed the PostgreSQL database URI, the database schema and the database anonymous role.
To get things right, it is advisable to follow the getting started (tutorial)[https://postgrest.org/en/v5.0/tutorials/tut0.html].
Resources  Home page Github repository StackOverflow Gitter  ]]></content:encoded>
      </item>
    
      <item>
        <title>Jitsi: video conference server</title>
        <link>/web/posts/jitsi/</link>
        <pubDate>Thu, 09 Aug 2018 06:00:00 +0000</pubDate>
        <guid>/web/posts/jitsi/</guid>
        <description>From it&amp;rsquo;s Github page:
Jitsi Meet is an open-source (Apache) WebRTC JavaScript application that uses Jitsi Videobridge to provide high quality, secure and scalable video conferences. You can see Jitsi Meet in action here at the session #482 of the VoIP Users Conference.
The Jitsi Meet client runs in your browser, without the need for installing anything on your computer. You can also try it out yourself at https://meet.jit.si .
Jitsi Meet allows for very efficient collaboration. It allows users to stream their desktop or only some windows. It also supports shared document editing with Etherpad.
</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[From it&amp;rsquo;s Github page:
Jitsi Meet is an open-source (Apache) WebRTC JavaScript application that uses Jitsi Videobridge to provide high quality, secure and scalable video conferences. You can see Jitsi Meet in action here at the session #482 of the VoIP Users Conference.
The Jitsi Meet client runs in your browser, without the need for installing anything on your computer. You can also try it out yourself at https://meet.jit.si .
Jitsi Meet allows for very efficient collaboration. It allows users to stream their desktop or only some windows. It also supports shared document editing with Etherpad.
Introduction We want to offer a secure video conference service for our company.We selected jitsi-meet as our video conference platform because it meets all our requirements.
As soon as we check their documentation, it’s clear they only support Ubuntu and Debian Linux distributions. But they also provide hints to do a manual install of their software.
In this document we will set up and install a single instance of this platform using Slackware 64 bits Current.
Service architecture The general architecture of the service as per their documentation is:
&#43; &#43; | | | | v | 443 | &#43;-------&#43; | | | | | NginX | | | | | &#43;--&#43;-&#43;--&#43; | | | | &#43;------------&#43; | | &#43;--------------&#43; | | | | | | | | | jitsi-meet &#43;&amp;lt;---&#43; &#43;---&amp;gt;&#43; prosody/xmpp | | | |files 5280 | | | &#43;------------&#43; &#43;--------------&#43; v 5222,5347^ ^5347 4443 &#43;--------&#43; | | &#43;-------------&#43; | | | | | | | jicofo &#43;----^ ^----&#43; videobridge | | | | | &#43;--------&#43; &#43;-------------&#43; jitsi-meet basic requirements are:
 A web server with a valid SSL certificate,
 The Prosody Jabber service, with their JWT plug-in
 The Jitsi VideoBridge service
 The Jitsi Conference Focus (jicofo) service
 The Java platform 8
 The Lua platform 5
  Also we are going to need:
 Four different secrets for components communication
 A prosody user and group
  Software packages We have identified what software we need to install in our server to make jitsi-meet work and created SlackBuild scripts for them. You can check our source code repository or our binary packages at slackware.es.
We also used packages from slackbuilds.org, like the prosody server package, and also we used those scripts as a base for our own.
├── caddy-0.11-x86_64-1_es.tgz ├── jdk-8u181-x86_64-1.txz ├── jitsi │ ├── jicofo-1.1-x86_64-1_es.tgz │ ├── jitsi-meet-1.1-x86_64-1_es.tgz │ ├── jitsi-meet-token-1.1-x86_64-1_es.tgz │ └── jitsi-videobridge-1.1-linux-x64-1_es.tgz └── prosody ├── LuaBitOp-1.0.2-x86_64-1_SBo.tgz ├── lbase64-5.1--1_SBo.tgz ├── lua-5.1.5-x86_64-1_SBo.tgz ├── lua-cjson-2.1.0-x86_64-1_SBo.tgz ├── lua-filesystem-1.6.3-x86_64-1_SBo.tgz ├── lua-zlib-20140201_c0014bc-x86_64-1_SBo.tgz ├── luacrypto-0.5.1-x86_64-1_SBo.tgz ├── luaevent-0.4.3-x86_64-1_SBo.tgz ├── luaexpat-1.3.0-x86_64-1_SBo.tgz ├── luarocks-2.4.1-x86_64-1_SBo.tgz ├── luasec-0.7-x86_64-1_SBo.tgz ├── luasocket-3.0_rc1-x86_64-1_SBo.tgz └── prosody-0.10.2-x86_64-1_SBo.tgz For the Java package, we used the Slackware extras SlackBuild located in extra folder of the Slackware distribution.
We created startup scripts and a basic configuration files and included them on each package.
If you want to build your own, just download the source and run the SlackBuild scripts as usual.
The only software we do not created a package for was the Let&amp;rsquo;s Encrypt client.
Package installation After building the packages (you can download them from our binary repository), we install them using installpkg as usual.
By default the startup scripts are marked for execution and are installed in /etc/rc.d
The prosody packages install their software in /usr prefix, while the jisi packages install in /opt prefix.
Web server and SSL certificate We have chosen the open source Caddy as our web server. Our package builds the Github version without any plug-ins, and install /etc/rc.d/rc.caddy as a startup script and /etc/caddy/Caddyfile as a default configuration file.
Our Caddyfile mimics the NGINX configuration provided by the jitsi-meeet team at their repository
https://server.domain.com { root /opt/jitsi-meet tls /etc/acme.sh/server.domain.com/fullchain.cer /etc/acme.sh/server.domain.com/server.domain.com.key rewrite /room.* / proxy /http-bind server.domain.com:5280 log /var/log/caddy/access.log } The rewrite rule only allows this prosody to create rooms that start with the word room. We can be more creative to mimic better the NGINX configuration but this serves our purpose well.
Caddy integrates with Let&amp;rsquo;s encrypt certificates automatically, but we are going to use acme.sh client because we want to integrate the certificates in other components and open the possibility to change our web server if we need to. See the wiki for the advanced installation proceess.
# curl https://get.acme.sh | sh -s -- --install --home /etc/acme.sh We want acme.sh to install in /etc becasue the certificates will be read by multiple components of the system.
To get our certificates we set up acme.sh to answer Let&amp;rsquo;s encrypt challenge using Cloudflare DNS service:
# export CF_Key=&amp;#34;asdfgasdfgasdfgasdfg&amp;#34; # export CF_Email=&amp;#34;me@email.com&amp;#34; # acme.sh --issue --dns dns_cf -d server.domain.com -d auth.server.domain.com # Note we need to ask for auth.server.domain.com as well, to use the certificate with prosody. Also note that acme.sh will add a cron job to renew certificates monthly.
We can start our web server using /etc/rc.d/rc.caddy start command and check the log files in /var/log/caddy/to search for errors.
Prosody server Prosody is used by the jitsi-meet platform to route messages, enable chat, etc. The configuration file is in /etc/prosody.
We need to modify the main configuration file /etc/prosody/prosody.lua.cfg to include the following lines
plugin_paths = { &amp;#34;/opt/jitsi-meet-token/&amp;#34; } Include &amp;#34;server.domain.com.cfg.lua&amp;#34; With those lines we enable the jitsi-meet plugins for prosody and include a new configuration file which will contain our hosts parameters:
VirtualHost &amp;#34;server.domain.com&amp;#34; authentication = &amp;#34;token&amp;#34; app_id = &amp;#34;server.domain.com&amp;#34;; app_secret = &amp;#34;jwt-secret&amp;#34;; allow_empty_token = false; ssl = { key = &amp;#34;/etc/acme.sh/server.domain.com/server.domain.com.key&amp;#34;; certificate = &amp;#34;/etc/acme.sh/server.domain.com/fullchain.cer&amp;#34;; } modules_enabled = { &amp;#34;bosh&amp;#34;; &amp;#34;pubsub&amp;#34;; &amp;#34;ping&amp;#34;; } c2s_require_encryption = false Component &amp;#34;conference.server.domain.com&amp;#34; &amp;#34;muc&amp;#34; modules_enabled = { &amp;#34;token_verification&amp;#34; } storage = &amp;#34;internal&amp;#34; admins = { &amp;#34;focus@auth.server.domain.com&amp;#34; } Component &amp;#34;jitsi-videobridge.server.domain.com&amp;#34; component_secret = &amp;#34;videobridge-secret&amp;#34; VirtualHost &amp;#34;auth.server.domain.com&amp;#34; ssl = { key = &amp;#34;/etc/acme.sh/server.domain.com/server.domain.com.key&amp;#34;; certificate = &amp;#34;/etc/acme.sh/server.domain.com/fullchain.cer&amp;#34;; } authentication = &amp;#34;internal_plain&amp;#34; Component &amp;#34;focus.server.domain.com&amp;#34; component_secret = &amp;#34;jicofo-secret&amp;#34; Before starting prosody, we create an user and group called prosody. The log files for prosody will be in /home/prosody. Also we need to copy our certificates to /etc/prosody/certs/ as shown in the configuration file, as prosody user is not able to read them from /root/acme.sh.
Start prosody server with the command # prosodyctl start and check the log files.
# prosodyctl register focus auth.jitsi.example.com focus-user-secret # prosodyctl restart Jitsi video bridge server The configuration files for the service are located in /etc/jitsi/videobridge. We need to update the config file with the data of our installation:
# Jitsi Videobridge settings # sets the XMPP domain (default: none) JVB_HOSTNAME=server.domain.com # sets the hostname of the XMPP server (default: domain if set, localhost otherwise) JVB_HOST= # sets the port of the XMPP server (default: 5275) JVB_PORT=5347 # sets the shared secret used to authenticate to the XMPP server JVB_SECRET=videobridge-secret # extra options to pass to the JVB daemon JVB_OPTS=--apis=rest,xmpp # adds java system props that are passed to jvb (default are for home and logging config file) JAVA_SYS_PROPS=&amp;#34;$JVB_EXTRA_JVM_PARAMS -Dnet.java.sip.communicator.SC_HOME_DIR_LOCATION=/etc/jitsi -Dnet.java.sip.communicator.SC_HOME_DIR_NAME=videobridge -Dnet.java.sip.communicator.SC_LOG_DIR_LOCATION=/var/log/jitsi -Djava.util.logging.config.file=/etc/jitsi/videobridge/logging.properties&amp;#34; Also we need to create the Java Key Store so clients can connect to the video bridge using SSL. We have included in the jitsi-videobridge package a tool called upgrade-cert.sh to create the store for us using the Let&amp;rsquo;s Encrypt certificates:
#!/bin/bash  ACME=&amp;#34;/etc/acme.sh&amp;#34; SERVER=&amp;#34;server.domain.com&amp;#34; PASSWORD_STORE=&amp;#34;changeit&amp;#34; openssl pkcs12 \  -export \  -in $ACME/$SERVER/fullchain.cer \  -inkey $ACME/$SERVER/$SERVER.key \  -out $SERVER.p12 \  -name $SERVER keytool -importkeystore \  -deststorepass $PASSWORD_STORE \  -destkeystore $SERVER.jks \  -srckeystore $SERVER.p12 \  -srcstoretype PKCS12 \  -alias $SERVER Customize your server name and password store and run the script to create server.domain.com.jks. Then update the sip-communicator.properties file accordinly (change the port to 4443 instead of 443 on the file to avoid conflicts).
You also might want to add the script to run when acme.sh renews the certificates.
We start the service using the provided script /etc/rc.d/rc.videobridge start and check the logs in /var/log/jitsi/jvb.log for errors.
Jitsi Conference Focus The configuration files for the service are located in /etc/jitsi/jicofo. We need to update the config file with the data of our installation:
# Jitsi Conference Focus settings # sets the host name of the XMPP server JICOFO_HOST=localhost # sets the XMPP domain (default: none) JICOFO_HOSTNAME=server.domain.com # sets the secret used to authenticate as an XMPP component JICOFO_SECRET=jicofo-secret # sets the port to use for the XMPP component connection JICOFO_PORT=5347 # sets the XMPP domain name to use for XMPP user logins JICOFO_AUTH_DOMAIN=auth.server.domain.com # sets the username to use for XMPP user logins JICOFO_AUTH_USER=focus # sets the password to use for XMPP user logins JICOFO_AUTH_PASSWORD=focus-user-secret # extra options to pass to the jicofo daemon JICOFO_OPTS=&amp;#34;&amp;#34; # adds java system props that are passed to jicofo (default are for home and logging config file) JAVA_SYS_PROPS=&amp;#34;-Dnet.java.sip.communicator.SC_HOME_DIR_LOCATION=/etc/jitsi -Dnet.java.sip.communicator.SC_HOME_DIR_NAME=jicofo -Dnet.java.sip.communicator.SC_LOG_DIR_LOCATION=/var/log/jitsi -Djava.util.logging.config.file=/etc/jitsi/jicofo/logging.properties&amp;#34; We start the service using the provided script /etc/rc.d/rc.jicofo start and check the logs in /var/log/jitsi/jvb.log for errors.
Jitsi Meet Application The jitsi meet application is in /opt/jitsi-meet. Because the Caddy web server does not have server side includes, we need to edit index.html and include the needed javascript files:
&amp;lt;script src=&amp;#34;/config.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;libs/do_external_connect.min.js?v=1&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;/interface_config.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;/logging_config.js&amp;#34; --&amp;gt;&amp;lt;/script&amp;gt; Also we might want to include the file title.html in the header section of the index.html.
Using the service We have configured the service to use JWT authentication. Following the documentation at jitsi-meet repository and using the JWT Debugger at jwt.io, we can generate a link like:
https://server.domain.com/roomXXX?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6Ik...... To enter a room, paste the link into the browser.
]]></content:encoded>
      </item>
    
      <item>
        <title>Disk usage</title>
        <link>/web/posts/diskusage/</link>
        <pubDate>Sat, 04 Aug 2018 08:01:21 +0000</pubDate>
        <guid>/web/posts/diskusage/</guid>
        <description>In this post we will explore how to free disk space without reinstalling the system, and will present some scripts to help in the process.
</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[In this post we will explore how to free disk space without reinstalling the system, and will present some scripts to help in the process.
Introduction After some time using your system, installing new software and trying out settings, it&amp;rsquo;s inevitable to find that the disk usage is growing.
It could be a daunting process to free disk space, and most people will reinstall the systems again, adding to the new installation the experience got with the old one.
It&amp;rsquo;s common to think the in the new system, this problem will go away because you&amp;rsquo;ve learned a lot, and the system space will remain low, while only your data will increase. But on my experience, most people install again the operating system to clean it out.
A new installed Slackware, using the recommended installation process, installs aournd 10GB of software in your computer. But poking around and trying out software, can get you to 40GB in no time.
Our strategy to clean up the system will be:
 check the filesystem to see where is used the space check temporary files check installed packages and see how much space the use check files which do not belong to any package  Useful tools There are multiple tools to get information about filesystem usage, for example:
 xdiskusage   xdiskusage analisys of /     ncdu  ncdu showing / disk usage statistics   But sometimes we need to understand the problem to be able to use those tools correctly. Also if you make our own tools we will be able to automate certain tasks.
Filesystem usage The du utility, which stands for disk usage, can give you the size of a file or a folder.
With no arguments du will print the size of all files and folders from the current folder. And with the options -s and -h will summarize and print information of the current folder converting the size from Kb to the biggest unite possible (Mb, Gb, etc.)
gdiazlo@darkstar:~$ du -sh 9.4G . gdiazlo@darkstar:~$  It also accepts a parameter to show which folder is the starting point to calculate sizes:
gdiazlo@darkstar:~$ du -sh $HOME 9.4G . gdiazlo@darkstar:~$  So knowing where is the space going, it might tempt us to do
gdiazlo@darkstar:~$ du -sh /* but be aware: du will try to calculate the size of all mounted filesystems, including CD-ROMs, network shares, and synthetic filesystems like /proc. That will slow the process or even show errors.
A solution found in superuser.com site works well on a system with multiple mounted filesystems.
root@darkstar:~# for a in /*; do mountpoint -q -- &amp;#34;$a&amp;#34; || du -s -h -x &amp;#34;$a&amp;#34;; done 13M /bin 35M /boot 31M /etc 9.4G /home 559M /lib 27M /lib64 16K /lost&#43;found 64K /media 56K /mnt 212M /opt 1.9G /root 24M /sbin 4.0K /srv 4.9G /tmp 16G /usr 4.9G /var root@darkstar:~#  We can see in the list the top 5 space users:
 /usr uses 16G of space /home uses 9.5G of space /var uses 4.9G of space /tmp uses 4.9G of space /root uses 1.9G of space  All that combined is 37.2G of space.
The space used in /usr and /var should correspond to files from the operating system: installed software, packages, logs, databases, and together they account for 20.9G of space.
The space used in /tmp should be disposable as it only serves the purpose to contain ephemeral information.
And the /rootand/home` contain personal files from the administrator and the users of the computer.
With this information we state a different strategy to each case:
 system files: check packages and files that do not belong to any installed package temporary files: delete them if possible administrator and user files: check the downloads and temporary files, delete on your discretion  Identify system files We read about package managemt in Slackware to devise an strategy to:
 calculate the space used by installed packages identify orphan files (not related to any package) and their disk usage  Disk usage by installed packages We analize the space each packae uses throught its metadata files stored in /var/log/packages.
To show the packages ordered by its uncompressed size in ascending order:
#!/bin/bash  for p in `ls -1 /var/log/packages`; do head -n 3 /var/log/packages/$p | awk &amp;#39; /PACKAGE NAME:/ { name=$3 } /UNCOMPRESSED PACKAGE SIZE:/ { size=$4 } END{ print size, &amp;#34; &amp;#34; , name }&amp;#39; done | numfmt --from=si | sort -n -k 1 | numfmt --to=si The script is not very fast, but produce good results:
root@darkstar:~# ./pkgsize-meta | tail -n 10 168M emacs-26.1-x86_64-1 176M seamonkey-2.49.4-x86_64-1 220M kernel-modules-4.14.60-x86_64-1 285M mariadb-10.3.8-x86_64-1 297M kernel-firmware-20180730_7b5835f-noarch-1 335M qt5-5.11.1-x86_64-1alien 428M texlive-2018.180630-x86_64-2 529M rust-1.28.0-x86_64-1 718M llvm-6.0.1-x86_64-1 800M kernel-source-4.14.60-noarch-1 root@darkstar:~# Another example is calculate the size of all packages toghether:
root@darkstar:~# ./pkgsize-meta | numfmt --from=si | awk &amp;#39;{print $1}&amp;#39; | paste -sd&#43; | bc | numfmt --to=si 13G root@darkstar:~#  An installed file can grow over time, and this script will not take that into account. We can look in the disk ourselves instead of using the size provided by the package&amp;rsquo;s metadata file:
#!/bin/bash  PKGS=&amp;#34;/var/log/packages&amp;#34; LOGFILE=$(mktemp /tmp/pkgsize.XXXXXX) packages=$(ls -1 ${PKGS}/$1) total=0 for p in ${packages[@]}; do files=($(cat $p | sed &amp;#39;1,/FILE LIST/d&amp;#39; | sed &amp;#39;s/^/\//g&amp;#39; | grep -v &amp;#34;\/$&amp;#34; )) pkgsize=$( for i in $(seq 0 200 ${#files[@]}); do echo $(stat --printf=&amp;#34;%s &amp;#34; ${files[@]:$i:200} 2&amp;gt;$LOGFILE) | sed &amp;#39;s/ /\n/g&amp;#39; done | paste -sd&#43; | bc ) echo $pkgsize $p | numfmt --to=si total=$(( total &#43; pkgsize )) done echo $total | numfmt --to=si 
root@darkstar:~# ./pkgsize kernel-source-* 784M /var/log/packages/kernel-source-4.14.60-noarch-1 784M In the examples, the kernel package reported to use 800M in the metadata file and 784M using stat agains all the files and adding the result.
With this information we may decide to delete the packages we don&amp;rsquo;t use.
Identify orphan files An orphan file does not correspond to any installed package. This could mean is software or data generated during the system use. Maybe we installed or tried to install applications that polluted our system with files and didn&amp;rsquo;t user the package management tools.
To decrease the number of orphan files, use Appimage or flatpak to install software which do not have a package for Slackware. Also consider making your own packages, it is easy and allows you to control all the files on your system.
We can devise a script to find all orphan files and list them along with their size in Kb. Be aware this script is slow and requires a considerable amount of RAM (around 400M on our case). See the contribution below for a better approach.
#!/bin/bash  LOGFILE=$(mktemp /tmp/pkgorphan.XXXXXX) files=() TMP=$(mktemp -d /tmp/orphan.XXXXXX) cd $TMP for p in `ls -1 /var/log/packages`; do cat /var/log/packages/$p |sed -e &amp;#39;1,/FILE LIST/d&amp;#39; | sed &amp;#39;s/^/\//g&amp;#39; | sed &amp;#39;s/\/$//g&amp;#39; done | sort -u &amp;gt; meta for i in usr bin sbin lib lib64 opt srv var etc root; do find /$i -type f done | sort -u &amp;gt; disk awk &amp;#39;NR==FNR { A[$1] ; next } !($1 in A) { print $1 }&amp;#39; meta disk &amp;gt; orphans files=($(cat orphans)) for i in $(seq 0 200 ${#files[@]}); do ls -d -s -1 ${files[@]:$i:200} 2&amp;gt;$LOGFILE done &amp;gt; orphans-size A brave soul on #irc contributed another way to look for orphans, with better performance:
#!bin/bash # This needs bash for arrays # # Author: Jakub Jankowski &amp;lt;shasta@slackware.pl&amp;gt; # ONLY_FSTYPES_RGXP=&amp;#39;^(btrfs|ext[234]|xfs|jfs)$&amp;#39; SKIP_PATHS=( &amp;#39;/root/*&amp;#39; &amp;#39;/home/*&amp;#39; &amp;#39;/mnt/*&amp;#39; &amp;#39;/var/run/*&amp;#39; &amp;#39;/var/tmp/*&amp;#39; &amp;#39;/var/spool/*&amp;#39; &amp;#39;/var/log/pkgtools/*&amp;#39; &amp;#39;/var/lib/pkgtools/*&amp;#39; &amp;#39;/var/lib/sbopkg/*&amp;#39; &amp;#39;/var/cache/lxc/*&amp;#39; &amp;#39;/usr/src/linux*&amp;#39; &amp;#39;/tmp/*&amp;#39; ) # create temporary files FROM_PKGS=$(mktemp) FROM_FS=$(mktemp) set -e # list all files/dirs brought by packages; # we are also stripping .new suffix as that&amp;#39;s how config # files come in, but they are later mv&amp;#39;d &amp;#34;foo.new&amp;#34; &amp;#34;foo&amp;#34; for pkg in /var/log/packages/*; do sed -e &amp;#39;1,/^FILE LIST:/d; /^\.\/$/d; /^install\//d; s,^,/,; s,\.new$,,; s,/$,,&amp;#39; &amp;#34;$pkg&amp;#34; done &amp;gt; &amp;#34;$FROM_PKGS&amp;#34; # find all files/directories on filesystem, but only if fs type is one of $ONLY_FSTYPES_RGXP; # on&amp;#39;t descend to other filesystems (-xdev), and ignore paths from $SKIP_PATHS declare -a EXCL=( ) for p in &amp;#34;${SKIP_PATHS[@]}&amp;#34;; do if [ ${#EXCL[@]} -eq 0 ]; then EXCL=( &amp;#34;${EXCL[@]}&amp;#34; &amp;#39;-path&amp;#39; &amp;#34;$p&amp;#34; &amp;#39;-prune&amp;#39; ) else EXCL=( &amp;#34;${EXCL[@]}&amp;#34; &amp;#39;-o&amp;#39; &amp;#39;-path&amp;#39; &amp;#34;$p&amp;#34; &amp;#39;-prune&amp;#39; ) fi done [ ${#EXCL[@]} -gt 0 ] &amp;amp;&amp;amp; EXCL=( &amp;#34;${EXCL[@]}&amp;#34; &amp;#39;-o&amp;#39; &amp;#39;-print&amp;#39; ) find $(awk -v fstypes=&amp;#34;$ONLY_FSTYPES_RGXP&amp;#34; &amp;#39;$3 ~ fstypes {print $2}&amp;#39; /proc/mounts) \  -xdev &amp;#34;${EXCL[@]}&amp;#34; 2&amp;gt;/dev/null &amp;gt; &amp;#34;$FROM_FS&amp;#34; # output needs to be sorted for join(1) to work LC_ALL=C sort -u -o &amp;#34;$FROM_PKGS&amp;#34; &amp;#34;$FROM_PKGS&amp;#34; LC_ALL=C sort -u -o &amp;#34;$FROM_FS&amp;#34; &amp;#34;$FROM_FS&amp;#34; # see which paths in $FROM_FS are not in $FROM_PKGS LC_ALL=C join -a 2 -v 2 &amp;#34;$FROM_PKGS&amp;#34; &amp;#34;$FROM_FS&amp;#34; # clean up other two temp files rm &amp;#34;$FROM_FS&amp;#34; &amp;#34;$FROM_PKGS&amp;#34; The script will give us a list of orphans. We can compute the size they use on disk using that list.
We can further explore the results the script generated in the file orphans-size:
 show the top-ten orphan files by its disk usage:  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | sort -k 1 -n -u | tail -n 10 | sed &amp;#39;s/ \//K \//&amp;#39; | numfmt --from=si --to=si 96M /var/lib/flatpak/repo/objects/05/91c08407fbaa7dccc4cbc541865d27d4714b14d51417dc658841e3cd96d489.commitmeta 105M /usr/local/cuda-9.2/lib64/libcufft_static.a 115M /usr/local/cuda-9.2/nsightee_plugins/com.nvidia.cuda.repo-1.0.0-SNAPSHOT.zip 117M /usr/local/cuda-9.2/lib64/libcusolver.so.9.2.148 124M /var/lib/flatpak/app/com.spotify.Client/x86_64/stable/0591c08407fbaa7dccc4cbc541865d27d4714b14d51417dc658841e3cd96d489/files/extra/share/spotify/libcef.so 132M /var/tmp/elvis1.ses 177M /usr/local/cuda-9.2/lib64/libnvgraph_static.a 252M /var/lib/flatpak/repo/objects/69/74b95360b298f4cfe1be4025689ea20e918b689a5110984b3ffe7d339faf45.file 252M /var/lib/flatpak/repo/objects/df/45dafc31028c33ba2b26b08342dfe4044937e54eb9a3305c1cea28b5e9dfb5.file 330M /var/cache/sbopkg/qt-everywhere-opensource-src-5.7.1.tar.xz root@darkstar:/tmp/orphan.xvA0L1#   summary the size of an specific folder  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | grep &amp;#34;/usr/local/cuda-9.2*&amp;#34; | awk &amp;#39;{print $1}&amp;#39; | sort -n -k 1 | paste -sd&#43; | bc | sed &amp;#39;s/$/K/&amp;#39; | numfmt --from=si --to=si 2.9G root@darkstar:/tmp/orphan.xvA0L1#   summary to the second level directory hierarchy  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | cut -d &amp;#39;/&amp;#39; -f 1,2,3 | sort -n -k 1 -u | awk &amp;#39;{size[$2]&#43;=$1}END{for (s in size){print size[s],&amp;#34; &amp;#34;, s}}&amp;#39; | sort -k1 -n | sed &amp;#39;s/ /K /&amp;#39; | numfmt --from=si --to=si | tail -n 10 88M /root/.cache 115M /usr/share 125M /root/NVIDIA_CUDA-9.2_Samples 138M /var/tmp 165M /opt/calibre 188M /usr/lib64 515M /var/cache 1.2G /root/latest 2.4G /var/lib 2.5G /usr/local root@darkstar:/tmp/orphan.xvA0L1# After all this work, isn&amp;rsquo;t there an application to work this out without arcane shell commands?
Delete unwanted files After the analysis we&amp;rsquo;ve identified where the disk space is and what kind of files use them:
 /usr/local contains 2.5G of unaccounted space, used by cuda, plan9ports and go installations /var/lib contains 2.4G of unaccounted space, used by pacakge tools like SlackBuilds or Flatpak. /root cotains 1.2G of unaccounted space, used by cuda and other scripts  Also we identified packages we don&amp;rsquo;t use which use a lot of disk space like MariaDB, Rust, or TeX.
With that in mind we can free up a couple of GB easily without breaking anything on the system, just deleting the folders with rm.
]]></content:encoded>
      </item>
    
      <item>
        <title>The Xterm</title>
        <link>/web/posts/xterm/</link>
        <pubDate>Thu, 02 Aug 2018 14:27:00 +0000</pubDate>
        <guid>/web/posts/xterm/</guid>
        <description>From it&amp;rsquo;s manual page xterm(1):
The xterm program is a terminal emulator for the X Window System. It provides DEC VT102/VT220 and selected features from higher-level terminals such as VT320/VT420/VT520 (VTxxx). It also provides Tektronix 4014 emulation for programs that cannot use the window system directly.If the underlying operating system supports terminal resizing capabilities (for example, the SIGWINCH signal in systems derived from 4.3BSD), xterm will use the facilities to notify programs running in the window whenever it is resized.
</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[From it&amp;rsquo;s manual page xterm(1):
The xterm program is a terminal emulator for the X Window System. It provides DEC VT102/VT220 and selected features from higher-level terminals such as VT320/VT420/VT520 (VTxxx). It also provides Tektronix 4014 emulation for programs that cannot use the window system directly.If the underlying operating system supports terminal resizing capabilities (for example, the SIGWINCH signal in systems derived from 4.3BSD), xterm will use the facilities to notify programs running in the window whenever it is resized.
It&amp;rsquo;s currently maintained and the changes can be followed in Thomas E. Dickey site
Features and configuration It&amp;rsquo;s reason to be, emulation of other terminals, should be considered on my opinion it&amp;rsquo;s major feature. It provides emulation for a lot of old terminals, so that software written long ago can be used on today systems, emulating the screens those computers had. XTerm still provides a fairly complete emulation of those terminals. See for example these Tektronix programs.
Fonts It can be condifured to use fonts supported by the FreeType library, which is pretty much any font you can find out there (TTF, OTF, etc.) It can only have one font size per session, so any given XTerm window will have the same font size on all the text buffer. But the size of the current font can be changed to multiple options (tiny, small, medium, huge, default) using the fonts menu (CTRL&#43;3rd mouse button click).
Xterm showing the contents of an .Xresources file   The font management in X is a bit messy, but you can have decent results with a bit of work.
Unicode Xterm is able to show unicode characters. There is an xterm wrapper uxterm which set up xterm to show them,as it not show them by default. But it does not work well with all the fonts. In case you need non latin output, I suggest you to use uterm wrapper and the default fonts. Unless you need it to do heavy work that you will need to search for a good font for your needs.
Xterm with htop application running   Note that this terminal font is rendered in your browser and might have better Unicode support. Below is an image of what appeared on the screen:
 Xterm screenshot of Unicode test    ncurses Xterm has the best support for ncurses programs AFAICT. It might me related to the fact that Thomas E. Dickey is related to both xterm and also ncruses.
xhtml export It has the feature to export the current window, not the whole buffer as an XHTML page. The terminals on this site have been generated using that functionality. Colors and ncurses are supported and the final result is quite good.
Xterm with calcurses application running   Xterm with htop application running   Note that the screen captures uses the default monospace font from your browser. I&amp;rsquo;m using Terminus (TTF) font as the monospace font in my browsers and the render of both consoles are just like I saw them in the Xterm.
Usability It&amp;rsquo;s menu system, the .Xresources file, and the config modifications you can apply without closing and restarting the session is a bit annoying. But the work I normally do in XTerm does not requiere such things.
You can serach using a printerCommand, like the one in the screenshot of my .Xresources file, but it would be nice if you could just do that in the current buffer
Performance I do not require a special performance of a terminal emulator. Also I have plenty of memory to run an XTerm from time to time.
Bugs The XTerm is famous for its difficult code, its bugs, and its complexity:
 cut/paste does not select tabs; instead spaces are selected. This is because the selection works from the array of displayed characters, on which tab/space conversion has already been performed. does not implement the autorepeat feature of VTxxx terminals. the program must be run with fixed (nonproportional) fonts. the home and end keys do not generate usable escape sequences, due to an indexing error. the Main Options menu is improperly constructed, due to incorrect indices after removing the logging toggle. This makes the list of signals off by one. very large screens (e.g., by using nil2 for a font) cause core dumps because the program uses a fixed array (200 lines) for adjusting pointers. certain types of key translations cause a core dump because the program does not check the event class before attempting to use events. ]]></content:encoded>
      </item>
    
      <item>
        <title>The Slackware Book</title>
        <link>/web/posts/slackbook/</link>
        <pubDate>Sat, 28 Jul 2018 08:01:21 +0000</pubDate>
        <guid>/web/posts/slackbook/</guid>
        <description>The Slackware Book can be read online in its original form at: slackbook.
I&amp;rsquo;ll reproduce here the introduction paragraphs. Please consider to collaborate with the Slackware documentation project in it&amp;rsquo;s web site
</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[The Slackware Book can be read online in its original form at: slackbook.
I&amp;rsquo;ll reproduce here the introduction paragraphs. Please consider to collaborate with the Slackware documentation project in it&amp;rsquo;s web site
Why Use Slackware? Slackware has a long tradition of excellence. Started in 1992 and first released in 1993, Slackware is the oldest surviving commercial Linux distribution. Slackware&amp;rsquo;s focus on making a clean, simple Linux distribution that is as UNIX-like as possible makes it a natural choice for those people who really want to learn about Linux and other UNIX-like operating systems. In a 2012 interview, Slackware founder and benevolent dictator for life, Patrick Volkerding, put it thusly.
&amp;ldquo;I try not to let things get juggled around simply for the sake of making them different. People who come back to Slackware after a time tend to be pleasantly surprised that they don&amp;rsquo;t need to relearn how to do everything. This has given us quite a loyal following, for which I am grateful.&amp;rdquo;
Slackware&amp;rsquo;s simplicity makes it ideal for those users who want to create their own custom systems. Of course, Slackware is great in its own right as a desktop, workstation, or server as well.
Differences Compared to Other Linux Distributions There are a great number of differences between Slackware and other mainstream distributions such as Red Hat, Debian, and Ubuntu. Perhaps the greatest difference is the lack of &amp;ldquo;hand-holding&amp;rdquo; that Slackware will do for the administrator. Many of those other distributions ship with custom graphical configuration tools for all manner of services. In many cases, these configuration tools are the preferred method of setting up applications on these systems and will overwrite any changes you make to the configuration files via other means. These tools often make it easy (or at least possible) for a rookie with no in-depth understanding of his system to setup basic services; however, they also make it difficult to do anything too out of the ordinary. In contrast, Slackware expects you, the system administrator, to do these tasks on your own. Slackware provides no general purpose setup tools beyond those included with the source code published by upstream developers. This means there is often a somewhat steeper learning curve associated with Slackware, even for those users familiar with other Linux distributions, but also makes it much easier to do whatever you want with your operating system.
Also, you may hear users of other distributions say that Slackware has no package management system. This is completely and obviously false. Slackware has always had package management (see Chapter 17, Package Management for more information). What it does not have is automatic dependency resolution - Slackware&amp;rsquo;s package tools trade dependency management for simplicity, ease-of-use, and reliability.
Licensing Each piece of Slackware (this is true of all Linux distributions) is developed by different people (or teams of people), and each group has their own ideas about what it means to be &amp;ldquo;free&amp;rdquo;. Because of this, there are literally dozens and dozens of different licenses granting you different permissions regarding their use or distribution. Fortunately dealing with free software licenses isn&amp;rsquo;t as difficult as it may first appear. Most things are licensed with either the Gnu General Public License or the BSD license. Sometimes you&amp;rsquo;ll encounter a piece of software with a different license, but in almost all cases they are remarkably similar to either the GPL or the BSD license.
Probably the most popular license in use within the Free Software community is the GNU General Public License. The GPL was created by the Free Software Foundation, which actively works to create and distribute software that guarantees the freedoms which they believe are basic rights. In fact, this is the very group that coined the term &amp;ldquo;Free Software.&amp;rdquo; The GPL imposes no restrictions on the use of software. In fact, you don&amp;rsquo;t even have to accept the terms of the license in order to use the software, but you are not allowed to redistribute the software or any changes to it without abiding by the terms of the license agreement. A large number of software projects shipped with Slackware, from the Linux kernel itself to the Samba project, are released under the terms of the GPL.
Another very common license is the BSD license, which is arguably &amp;ldquo;more free&amp;rdquo; than the GPL because it imposes virtually no restrictions on derivative works. The BSD license simply requires that the copyright remain intact along with a simple disclaimer. Many of the utilities specific to Slackware are licensed with a BSD-style license, and this is the preferred license for many smaller projects and tools.
]]></content:encoded>
      </item>
    
  </channel>
</rss>
