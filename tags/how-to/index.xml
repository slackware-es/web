<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>How To on Slackware</title>
    <link>/tags/how-to/</link>
    <description>Recent content in How To on Slackware</description>
    <image>
      <title>How To on Slackware</title>
      <link>/tags/how-to/</link>
      <url>img/penguins.jpg</url>
    </image>
    <ttl>1440</ttl>
    <generator>Hugo 0.53</generator>
    <language>en-US</language>
    <lastBuildDate>Sun, 05 Aug 2018 23:01:21 +0000</lastBuildDate>
    
      <atom:link href="/tags/how-to/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>Shell</title>
        <link>/docs/shell/</link>
        <pubDate>Sun, 05 Aug 2018 23:01:21 +0000</pubDate>
        <guid>/docs/shell/</guid>
        <description>This document is a derivative of the Slackbook:bash and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.
What Is A Shell? A shell is a program that give access to the operating system&amp;rsquo;s services. In Slackware the command-line interface (CLI) shell is bash, the Bourne Again Shell.
The first program Slackware executes after you log into the system is the shell command-line interface:</description>
        <category domain="/categories/technology">Technology</category>
        <content:encoded><![CDATA[ This document is a derivative of the Slackbook:bash and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.
What Is A Shell? A shell is a program that give access to the operating system&amp;rsquo;s services. In Slackware the command-line interface (CLI) shell is bash, the Bourne Again Shell.
The first program Slackware executes after you log into the system is the shell command-line interface:
There are many shells included with a full install of Slackware, but in this chapter we will only discuss bash. Advanced users might want to consider using the powerful zsh, and users familiar with older UNIX systems might appreciate ksh or csh, but new users should stick to bash.
The main tasks a user does in the shell is executing commands, i.e. telling the computer what to do next.
Users can also program in the shell. Programs written in shell language are shell scripts and the Linux kernel execute them as if they were binary programs.
A lot of Slackware tools are written in bash.
A complete guide on how to use bash is available in its web. In this chapter we will make a gentle introduction to the bash shell, focused on its use in the Slackware Linux distribution.
Quick-start So you&amp;rsquo;ve installed Slackware and you&amp;rsquo;re staring at a terminal prompt, what now? Now would be a good time to learn about the basic command-line tools. And since you&amp;rsquo;re staring at a blinking curser, you may need a little help in knowing how to get around.
We type a command at the prompt and press the key enter, and the shell executes it. It prints the result of the command below and when the command ends shows the prompt again.
Here you have a quick reference of commands taken from the fantastic Introduction to Linux by the TLDP:
 ls: List files in the current working directory cd: Change directories passwd: Change the password for the current user file filename: Display file type of file with name filename cat textfile: Throws content of textfile on the screen pwd: Display present working directory exit or logout: Leave the current session man command: Read manual pages on command info command: Read Info pages on command apropos string: Search the whatis database for strings  And a quick reference on how to edit what you type at the prompt:
 Ctrl&#43;A: Move cursor to the beginning of the command line. Ctrl&#43;E: Move cursor to the end of the command line. Ctrl&#43;C: End a running program and return the prompt, see Chapter 4. Ctrl&#43;D: Log out of the current shell session, equal to typing exit or logout. Ctrl&#43;H: Generate a backspace character. Ctrl&#43;L: Clear this terminal. Ctrl&#43;R: Search command history, see Section 3.3.3.4. Ctrl&#43;Z: Suspend a program, see Chapter 4. ArrowLeft and ArrowRight: Move the cursor one place to the left or right on the command line, so you can insert characters at other places than just at the beginning and the end. ArrowUp and ArrowDown: Browse history. Go to the line you want to repeat, edit details and press Enter to save time. Shift&#43;PageUp and Shift&#43;PageDown: Browse terminal buffer (to see text that has &amp;ldquo;scrolled off&amp;rdquo; the screen). Tab: Command or filename completion; when multiple choices are possible, the system will either signal with an audio or visual bell, or, if too many choices are possible, ask you if you want to see them all. Tab Tab (Tab twice): Shows file or command completion possibilities.  The prompt It is the message the shell prints to show it is ready to accept new instructions. bash generates the prompt based in a template. The default template in Slackware is \u@\h:\w\$ which generate prompts like root@darkstar:~#. \u stands for the user name, \h stands for the host name \w stands for the current path in the filesystem and \$ shows if the user has administration privileges # or not $.
PS1 variable contains the template to configure the prompt.
Configuration The shell is configured editing the following files, depending on what kind of configuration we want to make.
 /etc/profile: The systemwide initialization file, executed for login shells ~/.bash_profile: The personal initialization file, executed for login shells ~/.bashrc: The individual per-interactive-shell startup file ~/.bash_logout: The individual login shell cleanup file, executed when a login shell exits ~/.inputrc: Individual readline initialization file  Those files accept bash commands as their content, and those commands are the ones which will configure the bash environment when it starts.
Environment An environment is a compound of properties and variables defined in the shell when it starts. We can change most without restarting the shell.
All shells make certain tasks easier for the user by keeping track of things in environment variables. An environment variable is a shorter name for some bit of information that the user wishes to store and make use of later. For example, the environment variable PS1 tells bash how to format its prompt. Other variables may tell applications how to run.
Setting your own environment variables is easy. bash includes two built-in functions for handling this: set and export. We can remove an environment with unset. Don&amp;rsquo;t panic if you accidentally unset an environment variable and don&amp;rsquo;t know what it would do. You can reset all the default variables by logging out of your terminal and logging back in. You can reference a variable by placing a dollar sign ($) in front.
darkstar:~$ set FOO=bar darkstar:~$ echo $FOO bar The primary difference between set and export is that export will make the variable available to any sub-shells. (A sub-shell is another shell running inside a parent shell.) You can see this behavior when working with the PS1 variable that controls the bash prompt.
darkstar:~$ set PS1=&amp;#39;FOO &amp;#39; darkstar:~$ export PS1=&amp;#39;FOO &amp;#39; FOO There are many important environment variables that bash and other shells use, but one of the most important ones you will run across is PATH. It contains a list of directories to search through for applications.
For example, top is in /usr/bin/top. You could run it by specifying the complete path, but if /usr/bin is in your PATH variable, bash will check there for you when you type top at the prompt. You will most likely first notice this when you try to run a program and it is not in your PATH.
darkstar:~$ ifconfig bash: ifconfig: command not found darkstar:~$ echo $PATH /usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/opt/www/htdig/bin:. Above, you see a typical PATH for a regular user (see the $ in the prompt). You can change it on your own the same as any other environment variable. If you login as root however, you&amp;rsquo;ll see that root has a different PATH.
darkstar:~$ su - Password: darkstar:~# echo $PATH /usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/usr/games:/opt/www/htdig/bin Writing commands (II) Wildcards Wildcards are symbols used as placeholders for other characters. The use case for these in a shell is to complete strings like file names.
The asterisk matches any character or a characters combination, including none. Thus b* would match strings like b, ba, bab, babc, bcdb, and so forth. Less common is the ?. This wildcard matches one instance of any character, so b? would match ba and bb, but not b or bab.
darkstar:~$ touch b ba bab darkstar:~$ ls * b ba bab darkstar:~$ ls b? ba No, the fun doesn&amp;rsquo;t stop there! Besides these two we also have the bracket pair &amp;ldquo;[ ]&amp;rdquo; which allows us to fine tune what we want to match. Whenever bash see the bracket pair, it substitutes the contents of the bracket with any combination of letters or numbers specified, as long as they are comma separated.
darkstar:~$ ls a[1-4,9] a1 a2 a3 a4 a9 We can specify a range of letters or numbers typing a - between the start and the end of the range.
bash treat capital and lower-case letters as different. All capital letters come before all lower-case letters in alphabetical order. This is important when working with ranges.
darkstar:~$ ls 1[W-b] 1W 1X 1Y 1Z 1a 1b darkstar:~$ ls 1[w-B] /bin/ls: cannot access 1[b-W]: No such file or directory In the second example, 1[b-W] isn&amp;rsquo;t a valid range, so the shell treats it as a filename, and since that file doesn&amp;rsquo;t exist, ls tells you so.
Tab Completion bash completes your commands and filenames when you write just press the key Tab. Even if you haven&amp;rsquo;t typed in enough text to identify a filename or command, the shell will fill in as much as it can for you. Hitting Tab a second time will make it display a list of all matches for you.
Input and Output Redirection One of the defining features of Linux and other UNIX-like operating systems is the number of small, simple applications and the ability to stack them together to create complex systems. In bash we can make the output of a command the input of another one or into a file.
A shell command has three channels to control its input/output operations:
 The standard output (stdout or 1) is where the commands write their result The standard error (stderr or 2) is where the commands write their errors The standard input (stdin or 0) is where the commands read their input  To get started, we will show you how to redirect the output (stdout) of a program to a file. We do this with the &amp;gt; character. When bash sees the &amp;gt; character, it redirects all the output to whatever file name follows.
darkstar:~$ echo foo foo darkstar:~$ echo foo &amp;gt; /tmp/bar darkstar:~$ cat /tmp/bar foo If we do not redirect the stdout of echo, it prints the string given as its argument to its stdout. But if we redirect that stdout to a file we cannot see the output of the echo command.
If /tmp/bar does not exist, bash creates it and write the output as its contents. If /tmp/bar exist, then its contents are over-written. This might not be the best idea if you want to keep those contents in place.
bash supports &amp;gt;&amp;gt; which will append the output to the file, instead of over-write it.
darkstar:~$ echo foo foo darkstar:~$ echo foo &amp;gt; /tmp/bar darkstar:~$ cat /tmp/bar foo darkstar:~$ echo foo2 &amp;gt;&amp;gt; /tmp/bar darkstar:~$ cat /tmp/bar foo foo2 You can also re-direct the standard error to a file using 2&amp;gt; instead of just &amp;gt;.
darkstar:~$ rm bar rm: cannot remove `bar&amp;#39;: No such file or directory darkstar:~$ rm bar 2&amp;gt; /tmp/foo darkstar:~$ cat /tmp/foo rm: cannot remove `bar&amp;#39;: No such file or directory You may also redirect the standard input with the &amp;lsquo;&amp;lt;&amp;rsquo; character, though it&amp;rsquo;s not used often.
darkstar:~$ fromdos &amp;lt; dosfile You can redirect the output of one program as input to another using the | character. bash uses pipes to connect the stdout of a command to the stdin of another.
darkstar:~$ ps auxw | grep getty root 2632 0.0 0.0 1656 532 tty2 Ss&#43; Feb21 0:00 /sbin/agetty 38400 tty2 linux root 3199 0.0 0.0 1656 528 tty3 Ss&#43; Feb15 0:00 /sbin/agetty 38400 tty3 linux root 3200 0.0 0.0 1656 532 tty4 Ss&#43; Feb15 0:00 /sbin/agetty 38400 tty4 linux root 3201 0.0 0.0 1656 532 tty5 Ss&#43; Feb15 0:00 /sbin/agetty 38400 tty5 linux root 3202 0.0 0.0 1660 536 tty6 Ss&#43; Feb15 0:00 /sbin/agetty 38400 tty6 linux Task Management bash has yet another cool feature to offer: the ability to suspend and resume tasks. This allows you halt a running process, perform other task, then resume it or make it run in the background. Upon pressing CTRL-Z,bash will suspend the running process and return you to a prompt. You can return to that process later. You can suspend multiple processes in this way. The jobs built-in command will display a list of suspended tasks.
darkstar:~$ jobs [1]- Stopped vi TODO [2]&#43; Stopped vi chapter_05.xml To return to a suspended task, run the fg built-in to bring the last suspended task back into the foreground. If you have multiple suspended tasks, you can specify a number as well to bring one to the foreground.
darkstar:~$ fg # &amp;#34;vi TODO&amp;#34; darkstar:~$ fg 1 # &amp;#34;vi chapter_05.xml&amp;#34; You can also background a task with bg. This allows the process to run without maintaining control of your shell. You can bring it back to the foreground with fg in the same way as suspended tasks. Also, if you type &amp;amp; at the end of a command, bash send it to the background.
Terminals Terminals were keyboards and monitors (sometimes even mice) wired into a mainframe or server via serial connections. Today however, most terminals are virtual. This allow users to connect to the computer without requiring expensive and often incompatible hardware.
Slackware Linux and other UNIX-like operating systems use virtual terminals to interact with its users.
The most common virtual terminals (every Slackware Linux machine will have at least one) are the gettys. agetty(8) runs six instances by default on Slackware and allows local users (those who can sit down in front of the computer and type at the keyboard) to login and run applications. Each of these gettys is available on different tty devices that are accessible by pressing the ALT key and one of the function keys from F1 through F6. Using these gettys allows you to login multiple times, perhaps as different users, and run applications in those users&amp;rsquo; shells.
On desktops, laptops, and other workstations where the user prefers a graphical interface, most terminals are graphical. Slackware includes many graphical terminals, but the most used are KDE&amp;rsquo;s konsole, XFCE&#39;s Terminal and the standard xterm.
If you are using a graphical interface, check your toolbars or menus. Each desktop environment or window manager has a virtual terminal (often called a terminal emulator), and they are all labeled differently. Typically though, you will find them under a &amp;ldquo;System&amp;rdquo; sub-menu in desktop environments. Executing any of these will give you a graphical terminal and automatically run your default shell.
Basic shell commands System Documentation Your Slackware Linux system comes with lots of built-in documentation for nearly every installed application. Perhaps the most common method of reading system documentation is man. man (short for manual) will bring up the included man-page for any application, system call, a configuration file, or library you tell it too. For example, man man will bring up the man-page for itself.
You may not always know what application you need to use for the task at hand. But man has built-in search abilities to help. Using the [-k] switch will make man to search for every man-page that matches your search terms.
The man-pages are organized into groups or sections by their content type. For example, Section 1 is for user applications. man will search each section in order and display the first match it finds. Sometimes you find that a man-page exists in more than one section for an entry. In that case, you will need to specify the exact section to look in.
In this book, all applications and several other things will have a number on their right-hand side in parentheses. This number is the man page section where you will find information on that tool.
darkstar:~$ man -k printf printf (1) - format and print data printf (3) - formatted output conversion darkstar:~$ man 3 printf The sections of the manual pages are: - Section 1: User Commands - Section 2: System Calls - Section 3: C Library Calls - Section 4: Devices - Section 5: File Formats / Protocols - Section 6: Games - Section 7: Conventions / Macro Packages - Section 8: System Administration - Section 9: Kernel API Descriptions - Section n: &amp;ldquo;New&amp;rdquo; - typically used to Tcl/Tk
Files and directories: The filesystem  In computing, a file system or filesystem controls how data is stored and retrieved. Without a file system, information placed in a storage medium would be one large body of data with no way to tell where one piece of information stops and the next begins. By separating the data into pieces and giving each piece a name, the information is easily isolated and identified. Taking its name from the way paper-based information systems are named, each group of data is called a &amp;#34;file&amp;#34;. The structure and logic rules used to manage the groups of information and their names is called a &amp;#34;file system&amp;#34; Wikipedia  In Slackware and other UNIX-like operating systems, the file systems is a hierarchical tree-like structure which starts at the root directory denoted by /. All other directories and files are referenced from its relation to the root.
Listing Files and Directory Contents We use ls(1) to list files and directories, their permissions, size, type, inode number, owner and group, and plenty of additional information. For example, let&amp;rsquo;s list what&amp;rsquo;s in the / directory for your new Slackware Linux system.
darkstar:~$ ls / bin/ dev/ home/ lost&#43;found/ mnt/ proc/ sbin/ sys/ usr/ boot/ etc/ lib/ media/ opt/ root/ srv/ tmp/ var/ Notice that each of the listings is a directory. These are distinguished from regular files due to the trailing /; standard files do not have a suffix. Executable files will have an asterisk suffix. But ls can do so much more. To get a view of the permissions of a file or directory, you must do a &amp;ldquo;long list&amp;rdquo;.
darkstar:~$ ls -l /home/alan/Desktop -rw-r--r-- 1 alan users 15624161 2007-09-21 13:02 9780596510480.pdf -rw-r--r-- 1 alan users 3829534 2007-09-14 12:56 imgscan.zip drwxr-xr-x 3 alan root 168 2007-09-17 21:01 ipod_hack/ drwxr-xr-x 2 alan users 200 2007-12-03 22:11 libgpod/ drwxr-xr-x 2 alan users 136 2007-09-30 03:16 playground/ A long listing lets you view the permissions, user and group ownership, file size, last modified date, and the file name itself. Notice that the first two entire are files, and the last three are directories. This is denoted by the first character on the line. Regular files get a &amp;ldquo;-&amp;rdquo;; directories get a &amp;ldquo;d&amp;rdquo;. There are several other file types with their own denominators. Symbolic links for example will have an &amp;ldquo;l&amp;rdquo;.
We&amp;rsquo;ll show you how to list dot-files, or hidden files. Unlike other operating systems such as Microsoft Windows, there is no special property that differentiates &amp;ldquo;hidden&amp;rdquo; files from &amp;ldquo;unhidden&amp;rdquo; files. A hidden file begins with a dot. To display these files along with all the others, you need to pass the [-a] argument to ls.
darkstar:~$ ls -a .xine/ .xinitrc-backup .xscreensaver .xsession-errors SBo/ .xinitrc .xinitrc-xfce .xsession .xwmconfig/ Shared/ You also likely noticed that your files and directories appear in different colors. Many of the enhanced features of ls such as these colors or the trailing characters showing file-type are special features of the ls program enabled by passing various arguments. As a convenience, Slackware sets up ls to use many of these optional arguments by default. These are controlled by the LS_OPTIONS and LS_COLORS environment variables.
Moving Around the Filesystem cd is the command used to change directories. Unlike most other commands, cd is not it&amp;rsquo;s own program, but is a shell built-in. That means cd does not have its own man page. You must check your shell&amp;rsquo;s documentation for more details on the cd you may be using. Mostly though, they all behave the same.
darkstar:~$ cd / darkstar:/$ls bin/ dev/ home/ lost&#43;found/ mnt/ proc/ sbin/ sys/ usr/ boot/ etc/ lib/ media/ opt/ root/ srv/ tmp/ var/ darkstar:/$cd /usr/local darkstar:/usr/local$ Notice how the prompt changed when we changed directories? The default Slackware shell does this as a quick, easy way to see your current directory, but this is not a cd function. If your shell doesn&amp;rsquo;t operate in this way, you can get your current working directory with the pwd(1) command.
bash4.4$ pwd /usr/local File and Directory Creation and Deletion While most applications can and will create their own files and directories, you&amp;rsquo;ll often want to do this on your own. It&amp;rsquo;s easy using touch(1) and mkdir(1).
touch modifies the time stamp on a file, but if that file doesn&amp;rsquo;t exist, it will be created.
darkstar:~/foo$ ls -l -rw-r--r-- 1 alan users 0 2012-01-18 15:01 bar1 darkstar:~/foo$ touch bar2 -rw-r--r-- 1 alan users 0 2012-01-18 15:01 bar1 -rw-r--r-- 1 alan users 0 2012-01-18 15:05 bar2 darkstar:~/foo$ touch bar1 -rw-r--r-- 1 alan users 0 2012-01-18 15:05 bar1 -rw-r--r-- 1 alan users 0 2012-01-18 15:05 bar2 Note how bar2 was created in our second command, and the third command updated the time stamp on bar1.
mkdir is used for making directories. mkdir foo will create the directory foo within the current working directory. You can also use the -p argument to create any missing parent directories.
darkstar:~$ mkdir foo darkstar:~$ mkdir /slack/foo/bar/ mkdir: cannot create directory `/slack/foo/bar/&amp;#39;: No such file or directory darkstar:~$ mkdir -p /slack/foo/bar/ In the latter case, mkdir will first create /slack, then /slack/foo, and /slack/foo/bar. If you failed to use the [-p] argument, man would fail to create /slack/foo/bar unless the first two already existed, as you saw in the example.
Removing a file is as easy as creating one. The rm(1) command will remove a file (assuming you have permission to do this). There are a few common arguments to rm. The first is [-f] and is used to force the removal of a file you may lack explicit permission to delete. The [-r] argument will remove directories and their contents recursively.
There is another tool to remove directories, the humble rmdir(1). rmdir will only remove directories that are empty and complain about those that contain files or sub-directories.
darkstar:~$ ls foo_1/ foo_2/ darkstar:~$ ls foo_1 bar_1 darkstar:~$ rmdir foo_1 rmdir: foo/: Directory not empty darkstar:~$ rm foo_1/bar darkstar:~$ rmdir foo_1 darkstar:~$ ls foo_2 bar_2/ darkstar:~$ rm -fr foo_2 darkstar:~$ ls Links Links are a method of referring to one file by multiple names. By using the ln(1) application, a user can reference one file with multiple names. The two files are not carbon-copies of one another, but rather are the same file, just with a different name. To remove the file, all of its names must be deleted. (This is the result of how rm and other tools like it work. Rather than remove the contents of the file, they remove the reference to the file, freeing that space to be re-used. ln will create a second reference or &amp;ldquo;link&amp;rdquo; to that file.)
darkstar:~$ ln /etc/slackware-version foo darkstar:~$ cat foo Slackware 14.0 darkstar:~$ ls -l /etc/slackware-version foo -rw-r--r-- 1 root root 17 2007-06-10 02:23 /etc/slackware-version -rw-r--r-- 1 root root 17 2007-06-10 02:23 foo Another type of link exists, the symlink. Symlinks, rather than being another reference to the same file, are a special file in their own right. These symlinks point to another file or directory. The primary advantage of symlinks is that they can refer to directories and files, and they can span multiple filesystems. We create them with the [-s] argument.
darkstar:~$ ln -s /etc/slackware-version foo darkstar:~$ cat foo Slackware 140 darkstar:~$ ls -l /etc/slackware-version foo -rw-r--r-- 1 root root 17 2007-06-10 02:23 /etc/slackware-version lrwxrwxrwx 1 root root 22 2008-01-25 04:16 foo -&amp;gt; /etc/slackware-version When using symlinks, remember that if the original file is deleted, your symlink is useless; it points at a file that doesn&amp;rsquo;t exist anymore.
Reading files UNIX and UNIX-like operating systems use text files extensively, and that at some point in time, the system&amp;rsquo;s users will need to read and modify them. There are plenty of ways of reading these files, and we&amp;rsquo;ll show you the most common ones.
In the early days, if you wanted to see the contents of a file you would use cat(1) to view them. cat is a simple program, which takes one or more files, concatenates them (hence the name) and sends them to the standard output, which is usually your terminal screen.
This was fine when the file was small and wouldn&amp;rsquo;t scroll off the screen, but inadequate for larger files as it had no built-in way of moving within a document and reading it a paragraph at a time. Today, cat is still used predominately in scripts or for joining two or more files into one.
darkstar:~$ cat /etc/slackware-version Slackware 14.2 Given the limitations of cat some very intelligent people sat down and worked on an application to let them read documents one page at a time. Such applications began to be known as &amp;ldquo;pagers&amp;rdquo;. One of the earliest of these was more(1), named because it would let you see &amp;ldquo;more&amp;rdquo; of the file whenever you wanted.
more more will display the first few lines of a text file until your screen is full, then pause. Once you&amp;rsquo;ve read through that screen, you can proceed down one line by pressing Enter, or an entire screen by pressing Space, or by a specified number of lines by typing a number and then the Space bar. more can also search through a text file for keywords; once you&amp;rsquo;ve displayed a file in more, press the / key and enter a keyword. Upon pressing Enter, the text will scroll until it finds the next match.
This is a big improvement over cat, but still suffers from some annoying flaws; more cannot scroll back up through a piped file to allow you to read something you might have missed, the search function does not highlight its results, there is no horizontal scrolling, and so on.
less To address the short-comings of more, a new pager was developed and ironically dubbed less(1). less is a powerful pager that supports all the functions of more while adding lots of additional features. To begin with, less allows you to use your arrow keys to control movement within the document.
Due to its popularity, many Linux distributions have excluded more in favor of less. Slackware includes both. Slackware also includes a handy little pre-processor for less called lesspipe.sh. This allows a user to execute less on several non-text files. lesspipe.sh will generate text output from running a command on these files, and display it in less.
Less provides as much functionality as one might expect from a text editor without being a text editor. We can move line-by-line can be done vi-style with j and k, or with the arrow keys, or Enter. In the event that a file is too wide to fit on one screen, you can even scroll with the left and right arrow keys. The g key takes you to the top of the file, while G takes you to the end.
Searching is done as with more, by typing the / key and then your search string, but notice how the search results are highlighted for you, and typing n will take you to the next occurrence of the result while N takes you to the previous occurrence.
Also as with more, files may be opened directly in less or piped to it:
darkstar:~$ less /usr/doc/less-*/README darkstar:~$ cat /usr/doc/less*/README /usr/doc/util-linux*/README | less There is much more to less; from within the application, type h for a full list of commands.
Archive and Compression Everyone needs to package a lot of small files together for easy storage from time to time, or perhaps you need to compress very large files into a more manageable size? Maybe you want to do both together? there are several tools to do just that.
zip and unzip You&amp;rsquo;re probably familiar with .zip files. These are compressed files that contain other files and directories.
To create a zip file, you&amp;rsquo;ll use the zip(1) command. You can compress either files or directories (or both) with zip, but you must use the [-r] argument for recursive action to deal with directories.
darkstar:~$ zip -r /tmp/home.zip /home darkstar:~$ zip /tmp/large_file.zip /tmp/large_file The order of the arguments is very important. The first filename must be the zip file to create (zip will add the .zip file extension for you) and the rest are files or directories to be added to the zip file.
unzip(1) will decompress a zip archive file.
darkstar:~$ unzip /tmp/home.zip gzip One of the oldest compression tools included in Slackware is gzip(1), a compression tool which operate on a single file at a time or stream at a time. While zip is both a compression and an archival tool, gzip does only compression. At first glance this seems like a draw-back, but it is a strength. The UNIX philosophy of making small tools that do their small jobs well allows us to combine them in myriad ways. To compress a file (or multiple files), pass them as arguments to gzip. Whenever gzip compresses a file, it adds a .gz extension and removes the original file.
darkstar:~$ gzip /tmp/large_file Decompressing is just as straight-forward with gunzip which will create a new uncompressed file and delete the old one.
darkstar:~$ gunzip /tmp/large_file.gz darkstar:~$ ls /tmp/large_file* /tmp/large_file But suppose we don&amp;rsquo;t want to delete the old compressed file, we want to read its contents or send them as input to another program? The zcat program will read the gzip file, decompress it in memory, and send the contents to the standard output.
darkstar:~$ zcat /tmp/large_file.gz Wed Aug 26 10:00:38 CDT 2009 Slackware 13.0 x86 is released as stable! Thanks to everyone who helped make this release possible -- see the RELEASE_NOTES for the credits. The ISOs are off to the replicator. This time it will be a 6 CD-ROM 32-bit set and a dual-sided 32-bit/64-bit x86/x86_64 DVD. We&amp;#39;re taking pre-orders now at store.slackware.com. Please consider picking up a copy to help support the project. Once again, thanks to the entire Slackware community for all the help testing and fixing things and offering suggestions during this development cycle. bzip2 One alternative to gzip is the bzip2(1)xt compression utility which works in almost the same way. The advantage to bzip2 is that it boasts greater compression strength. Achieving that greater compression is a slow and CPU-intensive process, so bzip2 typical takes much longer to run than other alternatives.
XZ / LZMA The latest compression utility added to Slackware is xz, which implements the LZMA compression algorithm. This is faster than bzip2 and often compresses better. In fact, its blend of speed and compression strength caused it to replace gzip as the compression scheme of choice for Slackware. We can compress files using the [-z] argument, and decompression with [-d].
darkstar:~$ xz -z /tmp/large_file tar So great, we know how to compress files using many programs, but none of them can archive files like zip does.
The Tape Archiver, or tar(1) is the most used archival program in Slackware. Like other archival programs, tar generates a new file that contains other files and directories. It does not compress the generated file (often called a &amp;ldquo;tarball&amp;rdquo;) by default; however, the version of tar included in Slackware supports a variety of compression schemes, including the ones mentioned above.
Invoking tar can be as easy or as complicated as you like. Creating a tarball is done with the [-cvzf] arguments. Let&amp;rsquo;s look at these in depth.
 c: create a tarball x: extract the contents of a tarball t: display the contents of a tarball v: be more verbose z: use gzip compression j: use bzip2 compression J: use LZMA compression p: preserve permissions  tar requires more precision than other applications in the order of its arguments. The [-f] argument must be present when reading or writing to a file for example, and the very next thing to follow must be the filename. Consider the following examples.
darkstar:~$ tar -xvzf /tmp/tarball.tar.gz darkstar:~$ tar -xvfz /tmp/tarball.tar.gz Above, the first example works as you would expect, but the second fails because tar was told to open the z file rather than the expected /tmp/tarball.tar.gz.
Now we&amp;rsquo;ve got our arguments straightened out, lets look at a few examples of how to create and extract tarballs. As we&amp;rsquo;ve noted, the [-c] argument is used to create tarballs and [-x] extracts their contents. If we want to create or extract a compressed tarball though, we also have to specify the proper compression to use. If we don&amp;rsquo;t want to compress the tarball at all, we can leave these options out. The following command creates a new tarball using the gzip compression algorithm. While it&amp;rsquo;s not a strict requirement, it&amp;rsquo;s also good practice to add the .tar extension to all tarballs and whatever extension is used by the compression algorithm.
darkstar:~$ tar -czf /tmp/tarball.tar.gz /tmp/tarball/ ]]></content:encoded>
      </item>
    
      <item>
        <title>Package Management</title>
        <link>/docs/packages/</link>
        <pubDate>Sat, 04 Aug 2018 08:01:21 +0000</pubDate>
        <guid>/docs/packages/</guid>
        <description>This document is a derivative of the Slacbook:install. The aim is to produce an evolution and contribute it back to the original work.
Introduction Package management is an essential part of any Linux distribution. The software included in Slackware, along with many third-party tools, is distributed as source code. But compiling all those thousands of different applications and libraries is tedious and time consuming. That&amp;rsquo;s why many people prefer to install pre-compiled software packages.</description>
        <category domain="/categories/technology">Technology</category>
        <content:encoded><![CDATA[ This document is a derivative of the Slacbook:install. The aim is to produce an evolution and contribute it back to the original work.
Introduction Package management is an essential part of any Linux distribution. The software included in Slackware, along with many third-party tools, is distributed as source code. But compiling all those thousands of different applications and libraries is tedious and time consuming. That&amp;rsquo;s why many people prefer to install pre-compiled software packages. In fact, when you installed Slackware, the setup program run the package management tools on a list of packages. Here we&amp;rsquo;ll look at the various tools used for handling Slackware packages.
Slackware packages are tar files compressed by gzip or xz whose name contains the software name and version, the computer architecture of the included binaries and the package maintainer tag.
packageName-version-arch-tag.txz
The package management tools use metadata stored in /var/log/packages to do their operations. This metadata is generated when the package is installed, and stored in files named after the package. In the next Slackware release the metadata will be stored in /var/lib/pkgtool.
package metadata file   You can see the installed packages on your system by listing the contents of /var/log/packages, and on each file you can explore the following metadata fields:
 Package name Compressed package size Uncompressed package size Package location Package description File list  Slackware packages were compressed with the gzip compression utility, which was a good compromise between compression speed and size. But new compression schemes have been added and today, official Slackware packages use the xz utility and end with .txz extensions. Older packages, and many third party packages, still use the .tgz extension.
It&amp;rsquo;s worth emphasizing that .tgz and .txz (or, more succinctly, .t?z files) are standard, non-unique extensions for compressed .tar files. This has many advantages; they&amp;rsquo;re easy to build on any UNIX system (many other package formats require special tools), and they&amp;rsquo;re just as simple to de-construct.
However, it is also important to realize that just because all Slackware packages are .t?z files, not all .t?z files are Slackware packages. installpkg won&amp;rsquo;t install just any .t?z file, only Slackware packages.
A package contains an install folder with scripts to execute in the install process. The documentation of `makepkg contains the details of the install scripts.
Slackware package management tools do not automatically manage the package dependencies and there is no such information on the package metadata and are written in shell script.
In the next sections we describe the standard package management tools and mention non-standard ones for the advanced user.
pkgtool The way to perform package maintenance tasks is to invoke pkgtool, a menu-driven interface which allows you to install or remove packages and view the contents of those packages and the list of installed packages in a user-friendly ncurses interface.
pkgtool user interface   pkgtool is a convenient and easy way to perform the most basic tasks, but for more advanced work we need more flexible tools.
Installing, Removing, and Upgrading Packages While pkgtool scores points for convenience, `installpkg can handle odd tasks, such as installing a single package, installing an entire disk set of packages, or scripting an custom installation process.
installpkg takes a list of packages to install and installs them asking no questions. Like all Slackware package management tools, it assumes that you know what you&amp;rsquo;re doing and doesn&amp;rsquo;t pretend to be smarter than you. In its simplest form, installpkg takes a list of packages to install, and does what you would expect.
pkgtool user interface   You can install multiple packages at a time, and in fact use shell wild cards.The following installs all the “N” series packages from a mounted CD-ROM:
darkstar:~# installpkg /mnt/cdrom/slackware/n/*.txz removepkg will check the contents of the package metadata file and will remove all the files and directories for that package with one caveat. It will not remove files used by multiple installed packages, or non-empty directories.
darkstar:~# removepkg blackbox-0.70.1-i486-2.txz``` upgradepkg which first installs a new package, then removes whatever files and directories are left-over from the old package. It doesn&amp;rsquo;t check if the installed package has a higher version number than the “new” package, so it can also downgrade a package to older versions.
darkstar:~# upgradepkg blackbox-0.70.1-i486-2.txz &#43;============================================================================== | Upgrading blackbox-0.65.0-x86_64-4 package using ./blackbox-0.70.1-i486-2.txz &#43;============================================================================== Pre-installing package blackbox-0.70.1-i486-2... Removing package /var/log/packages/blackbox-0.65.0-x86_64-4-upgraded-2010-02-23,16:50:51... --&amp;gt; Deleting symlink /usr/share/blackbox/nls/POSIX --&amp;gt; Deleting symlink /usr/share/blackbox/nls/US_ASCII --&amp;gt; Deleting symlink /usr/share/blackbox/nls/de --&amp;gt; Deleting symlink /usr/share/blackbox/nls/en --&amp;gt; Deleting symlink /usr/share/blackbox/nls/en_GB ... Package blackbox-0.65.0-x86_64-4 upgraded with new package ./blackbox-0.70.1-i486-2.txz. These tools have useful arguments. For example, the –root to installpkg will install packages into an arbitrary directory. The –dry-run argument will instruct upgradepkg to tell you what it would attempt without changing the system. For complete details, refer to the man pages.
slackpkg Slackpkg is an automated tool for management of Slackware Linux Packages. It Appeared in /extra for the release of slackware-12.1, and since the release of slackware-12.2 they have included it in the ap/ series of a base installation.
You can find the latest version of slackpkg and its documentation at https://slackpkg.org.
Slacpkg can download packages from a mirror in Internet and install them into your computer. This is useful for security updates or application upgrades.
Without slackpkg, the process would be:
 Notice in the Slackware change log they have released an update. Look on your local Slackware mirror to find a download link of the package. Download the package from a Slackware mirror to your hard drive. Use either installpkg or pkgtool to install the downloaded package.  Slackpkg reduces the process to:
 Notice in the Slackware change log they have released an update. slackpkg install or upgrade the changed package  To use slackpkg, configure your system with a Slackware mirror by editing /etc/slackpkg/mirrors as root user. Find a mirror with your Slackware version and architecture and enable it by deleting the # at the start of the line. Only one mirror can be enabled at a time.
Then, update the local change log by issuing the command slackpkg update. This command will download the change log and will compare it with your local copy. If there are any differences, the local file is updated with the remote contents.
You should do this any time you notice they have posted a new package (check in with the Slackware change log once a day!).
To search for a package, use slackpkg search foo, and to install use slackpkg install foo.
You can manage the packages installed with slackpkg using pkgtool and the other standard package management commands.
For more information see the man pages for slackpkg(8) and slackpkg.conf(5), and see its website
There is also a novel tool called slackpkg&#43; which augments the current slackpkg tool to work with multiple repositories, for more information see its Guthub repository
slackbuilds Original source: slackbuilds.org
One of the frequent criticisms of Slackware is the lack of official packages available. While the official package set provides a good, stable, and flexible operating system (and is quite adequate for many individuals), the fact remains that many users want/need quite a few additional applications in order for it to meet their needs.
There are a few well-known third party package repositories, but many users justifiably do not want to install untrusted packages on their systems. For those users, the traditional solution has been to download the source code for desired applications and compile them manually.
This works, but introduces another set of problems associated with managing those applications; version updates and such require more of the admin&amp;rsquo;s time than precompiled packages, and lack of notes will often mean that the admin forgot which configure flags were used earlier (as well as any other special issues encountered).
In our opinion, the best solution to this problem is for the admin to automate the compile process using a SlackBuild script. Patrick Volkerding, the maintainer of Slackware, uses SlackBuild scripts to compile the official packages, so it makes sense for us to use the same idea for extra applications we want to add.
Our goal is to have the largest collection of SlackBuild scripts available while still ensuring that they are of the highest quality - we test every submission prior to inclusion in the repository. We do not now nor will we ever provide precompiled packages for any of the applications for which we have SlackBuild scripts - instead, we want the system administrator (that&amp;rsquo;s you) to be responsible for building the packages.
How to use it can be read in their fantastic documentation at their website
Building a package Original source: slack how-to
Configure and compile the source as you usually do:
./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc make Make a temporary destination directory available:
mkdir /tmp/build Install into the temporary directory:
make install DESTDIR=/tmp/build Now strip libs/bins within the temporary directory:
strip -s /tmp/build/usr/lib/* /tmp/build/usr/bin/* You also want to make sure that anything in /usr/man is gzipped before you make the package:
gzip -9 /tmp/build/usr/man/man?/*.? Create the install directory, this is where the description and install script will be stored:
cd /tmp/build mkdir install cd install One-liner (for the copy &amp;amp; paste people):
cd /tmp/build; mkdir install; cd install Using a text editor (or a tool), create a file called slack-desc and fill it with the following contents:
appname: appname (Short description of the application) appname: &amp;lt;this line is generally left blank&amp;gt; appname: Description of application - this description should be fairly appname: in-depth; in other words, make it clear what the package does (and appname: maybe include relevant links and/or instructions if there&amp;#39;s room), appname: but don&amp;#39;t get too verbose. appname: This file can have a maximum of eleven (11) lines of text preceded by appname: the &amp;#34;appname: &amp;#34; designation. appname: appname: It&amp;#39;s a good idea to include a link to the application&amp;#39;s homepage too. appname: The “appname” string must exactly match the application name portion of the Slackware package (for example, a package titled “gaim-1.5-i486-1.tgz” must have a slack-desc file with the  string of “gaim: ” rather than “Gaim: ” or “GAIM: ” or something else.
The first line must show the application name followed by a short description (enclosed in parentheses).
Create the actual package:
cd /tmp/build makepkg ../app-version-arch-tag.tgz (The dashes should appear as above, so if the version has a subversion like say “1.0 RC2” make sure you use 1.0_RC2 not 1.0-RC2. The arch should be something like “i486” for example. The tag should consist of the build number and your initals, e.g. 1zb for Zaphod Beeblebrox&amp;rsquo;s first build, 2zb for his second build, etc. Official slackware packages have only numbers as tags.)
 When prompted to recreate symbolic links, say yes When prompted to reset permissions, say no  Note: Using makepkg -l y -c n will give you the same behaviour as answering yes to the symlinks question, and no to the permissions question.
If all went well, you can now install the package.
cd .. installpkg app-version-arch-tag.tgz ]]></content:encoded>
      </item>
    
      <item>
        <title>How to build your own Slackware</title>
        <link>/docs/build/</link>
        <pubDate>Sat, 28 Jul 2018 08:01:21 +0000</pubDate>
        <guid>/docs/build/</guid>
        <description> In this article we&amp;rsquo;re going to describe how to build your own slackware distribution based on the official disitribution.
To do that we will describe the process of generating a slackware image to use in cloud environments.
Prepare the environment We&amp;rsquo;re going to use the repository https://github.com/slacware-es/dev to upload all the scripts needed to build your own slackware distribution.
Select your packages Generate tag files Build installation media Install / distribute </description>
        <category domain="/categories/technology">Technology</category>
        <content:encoded><![CDATA[ In this article we&amp;rsquo;re going to describe how to build your own slackware distribution based on the official disitribution.
To do that we will describe the process of generating a slackware image to use in cloud environments.
Prepare the environment We&amp;rsquo;re going to use the repository https://github.com/slacware-es/dev to upload all the scripts needed to build your own slackware distribution.
Select your packages Generate tag files Build installation media Install / distribute ]]></content:encoded>
      </item>
    
      <item>
        <title>Slackware installation</title>
        <link>/docs/install/</link>
        <pubDate>Sat, 28 Jul 2018 08:01:21 +0000</pubDate>
        <guid>/docs/install/</guid>
        <description>This document is a derivative of the Slacbook:install and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.
Introduction Slackware&amp;rsquo;s installation is a bit more simplistic than that of most other Linux distributions and is very reminiscent of installing one of the varieties of BSD operating systems. If you&amp;rsquo;re familiar with those, you should feel right at home. If you&amp;rsquo;ve never installed Slackware or used a distribution that makes use of a non-graphical installer, you may feel a bit overwhelmed at first.</description>
        <category domain="/categories/technology">Technology</category>
        <content:encoded><![CDATA[ This document is a derivative of the Slacbook:install and Slackbook beta. The aim is to produce an evolution and contribute it back to the original work.
Introduction Slackware&amp;rsquo;s installation is a bit more simplistic than that of most other Linux distributions and is very reminiscent of installing one of the varieties of BSD operating systems. If you&amp;rsquo;re familiar with those, you should feel right at home. If you&amp;rsquo;ve never installed Slackware or used a distribution that makes use of a non-graphical installer, you may feel a bit overwhelmed at first. Don&amp;rsquo;t panic! The installation is very easy once you understand it, and it works on just about any x86 platform.
The latest versions of Slackware Linux are distributed on DVD or CD media, but Slackware can be installed in a variety of other ways. We&amp;rsquo;re only going to focus on the most common method - booting from a DVD - in this book. If you don&amp;rsquo;t have a CD or DVD drive, you might wish to take a look at the various README files inside the usb-and-pxe-installers directory at your favorite Slackware mirror. This directory includes the necessary files and instructions for booting the Slackware installer from a USB flash drive or from a network card that supports PXE. The files there are the best source of information available for such boot methods.
Starting with the 14.1 release, Slackware ISO images (both the ones available online as well as the discs sent out from the Slackware store) have been processed using isohybrid. This allows them to be written to a USB stick, which can then be booted and used as the install source.
A HOWTO on setting up a PXE boot server right off a Slackware installation medium (DVD or USB Stick) is available in this separate article: Out of the box Slackware PXE Server
Booting Booting the installer is simply a process of inserting the Slackware install disk into your CD or DVD drive and rebooting. You may have to enter your computer&amp;rsquo;s BIOS and alter the boot order to place the optical drive at a higher boot priority than your hard drives. Some computers allow you to change the boot order on the fly by pressing a specific function key during system boot-up. Since every computer is different, we can&amp;rsquo;t offer instructions on how to do this, but the method is simple on nearly all machines.
Once your computer boots from the CD you&amp;rsquo;ll be taken to a screen that allows you to enter any special kernel parameters. This is here primarily to allow you to use the installer as a sort of rescue disk. Some systems may need special kernel parameters in order to boot, but these are very rare exceptions to the norm. Most users can simply press enter to let the kernel boot.
Boot message   You should see a lot of text go flying across your screen. Don&amp;rsquo;t be alarmed, this is all perfectly normal. The text you see is generated by the kernel during boot-up as it discovers your hardware and prepares to load the operating system (in this case, the installer). You can later read these messages with the dmesg(1) command if you&amp;rsquo;re interested. Often these messages are very important for troubleshooting any hardware problems you may have. Once the kernel has completed its hardware discovery, the messages should stop and you&amp;rsquo;ll be given an option to load support for non-us keyboards.
Keyboard option pre setup   Entering 1 and pressing ENTER will give you a list of keyboard mappings. Simply select the mapping that matches your keyboard type and continue on.
Keyboard selection pre setup   Unlike other Linux distributions which boot you directly into a dedicated installer program, Slackware&amp;rsquo;s installer drops you into a limited Linux distribution loaded into your system&amp;rsquo;s RAM. This limited distribution is then used to run all the installation programs manually, or can be used in emergencies to fix a broken system that fails to boot. Now that you&amp;rsquo;re logged in as root (there is no password within the installer) it&amp;rsquo;s time to start setting up your disks. At this point, you may setup software RAID or LVM support if you wish or even an encrypted root partition, but those topics are outside of the scope of this book. I encourage you to refer to the excellent README_RAID.TXT, README_LVM.TXT, and README_CRYPT.TXT files on your CD if you desire to setup your system with these advanced tools. Most users won&amp;rsquo;t have any need to do so and should proceed directly to partitioning.
Partitioning The Slackware installation media comes with tools to partition a hard drive. Usually partitioning a hard disk process is composed of these steps:
 Identify computer disks Running the desired partitioning tool on the target HDD. Showing the current partition table to see if there are any installed partitions. If needed, deleting partitions. Create a new partition. Selecting the type and size of the new partition. Continuing to create partitions as planned. Changing types of the partition (Swap, Linux, Solaris, etc). Setting a bootable flag to a desired partition. Writing the partition table.  How to select which hard drive you want to install on could be a challenge on some machines. A modern desktop or laptop can have multiple devices with different naming.
To list the disks present on a device we can list which devies have been recognized by the kernel like:
Identify computer disks   Or on a more complex scenario:
Identify computer disks complex   If the IDs of the decies doest tell you anything, you might want to search for them to identify which disk it might be,
In the comples scenario we can see multiple NVME devices described by their brand and model number.
In this simple scenario (the first one), we select the /dev/sda device and execute the cfdisk program like cfdisk /dev/sda. Then, its UI appears:
Check free space on disk   We need to create a partition on the hard disk to contain our Slackware system. We can see our disk is empty and we can use that empty space to create a new partition. If there is no free space on your disk, the first step is to create free space by deleting used space. This is a dangerous operation, so be sure you don&amp;rsquo;t need anything from that disk before deleting partitions.
cfdisk will ask how much of that free space we want to assign to a partition when we select the option [New] and press enter.
Select partition size   If we plan to install the system boot loader in the boot sector of the partition, we need to mark it as bootable with the correspondent cfdisk menu. When its marked as bootable a * symbols appears under the Boot column.
Mark partition as bootable   In some situations we might need to create partitions of differnt types, for that we can change a partition type with the [Type] entry of the cfdisk program. We can select more than enought partition types.
Change partition type   We everything is done, and we&amp;rsquo;re satisfied with the disk partitioning, we need to write the changes to the disk, and exit the program using the [Quit] menu.
Write partition and exit   The Setup Program Now that you&amp;rsquo;ve created your partitions it&amp;rsquo;s time to run the setup program to install Slackware. setup will handle formatting partitions, installing packages, and running basic configuration scripts step-by-step. In order to do so, just type setup at your shell prompt.
Write partition and exit   Help If you&amp;rsquo;ve never installed Slackware before, you can get a very basic over-view of the Slackware installer by reading the Help menu. Most of the information here is on navigating through the installer which should be fairly intuitive, but if you&amp;rsquo;ve never used a curses-based program before you may find this useful.
Access setup program help   Keymap Before we go any further, Slackware gives you the opportunity to select a different mapping for your keyboard. If you&amp;rsquo;re using a standard US keyboard you can safely skip this step, but if you&amp;rsquo;re using an international keyboard you will want to select the correct mapping now. This ensures that the keys you press on your keyboard will do exactly what you expect them to do
Select keymap   Addswap If you created a swap partition, this step will allow you to enable it before running any memory-intensive activities like installing packages. swap space is essentially virtual memory. It&amp;rsquo;s a hard drive partition (or a file, though Slackware&amp;rsquo;s installer does not support swap files) where regions of active system memory get copied when your computer is out of useable RAM. This lets the computer “swap” programs in and out of active RAM, allowing you to use more memory than your computer actually has. This step will also add your swap partition to /etc/fstab so it will be available to your OS.
Target Our next step is selecting our root partition and any other partitions we&amp;rsquo;d like Slackware to utilize. You&amp;rsquo;ll be given a choice of filesystems to use and whether or not to format the partition. If you&amp;rsquo;re installing to a new partition you must format it. If you have a partition with data on it you&amp;rsquo;d like to save, don&amp;rsquo;t. For example, many users have a seperate /home partition used for user data and elect not to format it on install. This lets them install newer versions of Slackware without having to backup and restore this data.
Select target partition   Source Here you&amp;rsquo;ll tell the installer where to find the Slackware packages. The most common method is to use the Slackware install DVD or CDs, but various other options are available. If you have your packages installed to a partition that you setup in the previous step, you can install from that partition or a pre-mounted directory. (You may need to mount that partition with mount(8) first. See chapter 11 for more details.) Additionally, Slackware offers a variety of networked options such as NFS shares, FTP, HTTP, and Samba. If you select a network installation, Slackware will prompt you for TCP/IP information first. We&amp;rsquo;re only going to discuss installation from the DVD, but other methods are similar and straightforward.
Select source media   Select One unique feature of Slackware is its manner of dividing packages into disksets. At the beginning of time, network access to FTP servers was available only through incredibly slow 300 baud modems, so Slackware was split into disk sets that would fit onto floppy disks so users could download and install only those packages they were interested in. Today that practice continues and the installer allows you to chose which sets to install. This allows you to easily skip packages you may not want, such as X and KDE on headless servers or Emacs on everything. Please note that the “A” series is always required.
Select source media   Install Finally we get to the meat of the installer. At this stage, Slackware will ask you what method to use to chose packages. If this is your first time installing Slackware, the “full” method is highly recommended. Even if this isn&amp;rsquo;t your first time, you&amp;rsquo;ll probably want to use it anyway.
The “menu” and “expert” options allow you to choose individual packages to install and are of use to skilled users familiar with the OS. These methods allow such users to quickly prune packages from the installer to build a very minimal system. If you don&amp;rsquo;t know what you&amp;rsquo;re doing (sometimes even if you do) you&amp;rsquo;re likely to leave out crucial pieces of software and end up with a broken system.
The “newbie” method can be very helpful to a new user, but takes a very long time to install. This method will install all the required packages, then prompt you individually for every other package. The big advantage here is that is pauses and gives you a brief overview of the package contents. For a new user, this introduction into what is included with Slackware can be informative. For most other users it is a long and tedious process.
The “custom” and “tagpath” options should only be used by people with the greatest skill and expertise with Slackware. These methods allow the user to install packages from custom tagfiles. Tagfiles are only rarely used. We won&amp;rsquo;t discuss them in this book.
Select source media   If we select the recommended prompt mode we will see how the program install all selected series of packages and shows information for each package. It could be too fast to read in modern computers.
Installing packages   Configure Once all the packages are installed you&amp;rsquo;re nearly finished. At this stage, Slackware will prompt you with a variety of configuration tasks for your new operating system. Many of these are optional, but most users will need to set something up here. Depending on the packages you&amp;rsquo;ve installed, you may be offered different configuration options than the ones shown here, but we&amp;rsquo;ve included all the really important ones.
USB boot disk The first thing you&amp;rsquo;ll likely be prompted to do is setup a boot disk. In the past this was typically a 1.44MB floppy disk, but today&amp;rsquo;s Linux kernel is far too large to fit on a single floppy, so Slackware offers to create a bootable USB flash memory stick. Of course, your computer must support booting from USB in order to use a USB boot stick (most modern computers do). If you do not intend to use LILO or another traditional boot loader, you should consider making a USB boot stick. Please note that doing so will erase the contents of whatever memory stick you&amp;rsquo;re using, so be careful.
Make bootable USB   LILO: The Linux Loader Nearly everyone will need to setup the LInux LOader, LILO. LILO is in charge of booting the Linux kernel and connecting to an initrd or the root filesystem. Without it (or some other boot loader), your new Slackware operating system will not boot. Slackware offers a few options here. The “simple” method attempts to automatically configure LILO for your computer, and works well with very simple systems. If Slackware is the only operating system on your computer, it should configure and install LILO for you without any hassels. If you don&amp;rsquo;t trust the simpler method to work, or if you want to take an in-depth look at how to configure LILO, the “expert” method is really not all that complicated. This method will take you through each step and offer to setup dual-boot for Windows and other Linux operating systems. It also allows you to append kernel command parameters (most users will not need to specify any though).
Make bootable USB   On modern UEFI machines and on some virtualization environment LILO might not work, and you might need to install GRUB or boot directly the linux kernel from the UEFI partition.
Mouse: enable gpm This simple step allows you to configure and activate a console mouse for use outside of the graphical desktops. By activating a console mouse, you&amp;rsquo;ll be able to easily copy and paste from within the Slackware terminal. Most users will need to choose one of the first three options, but many are offered, and yes those ancient two-button serial mice do work.
Select mouse type   And then enable the gpm to enable mouse on the console at boot time.
Select mouse type   Network configuration If you don&amp;rsquo;t wish to configure your network at this stage, you may decline, but otherwise you&amp;rsquo;ll be prompted to provide a hostname for your computer.
For laptops and desktop computing (development workstation, family PC, etc.) you will need a Network Manager setup. For a server you might need something different. In this scenario we&amp;rsquo;re going to cover the laptop/home computing scenario.
First, select we want to setup the network now:
Confirm we want to setup our network   Enter a host name to describe your computer. You might need to type it often for other configurations, so choose wisely (only letters and numbers allowed).
Enter a host name   Enter a domain name. This is not used on home computer environmnent most of the time, so almost always can invent a domain name to put here like slackware.com.
Enter a domain name   Select the Network Manager option:
Select network manager   Then confirm the data we&amp;rsquo;ve entered is correct to continue the set up.
Confirm network set up   Start up services Once your network configuration is completed Slackware will prompt you to configure the startup services that you wish to run automatically upon boot. Helpful descriptions of each service appear both to the right of the service name as well as at the bottom of the screen. If you&amp;rsquo;re not sure what to turn on, you can safely leave the defaults in place. What services are started at boot time can be easily modified later with pkgtool.
The default ones are normally fine, but you might want to enable or disable some. The fewer you need the better normally.
Enable start up services   Time zone Every computer needs to keep track of the current time, and with so many timezones around the world you have to tell Slackware which one to use. If your computer&amp;rsquo;s hardware clock is set to UTC (Coordinated Universal Time), you&amp;rsquo;ll need to select that; most hardware clocks are not set to UTC from the factory (though you could set it that way on your own; Slackware doesn&amp;rsquo;t care). Then simply select your timezone from the list provided and off you go.
IF you have another OS like Microsoft Windows installed on your computer, your hardware clock would be set up to you local time. If you&amp;rsquo;re going to use Slackware as your system, you can choose the option you like more.
Setup hardware clock   If you selected that your hardware clock is sync&amp;rsquo;ed to UTC the timezone selection will show your local time and date correctly. In any case, the timezone is also needed when the clock is sync&amp;rsquo;ed to local time.
Set yout local timezone   Window manager If you installed the X disk set, you&amp;rsquo;ll be prompted to select a default window manager or desktop environment. What you select here will apply to every user on your computer, unless that user decides to run xwmconfig(1) and choose a different one. Don&amp;rsquo;t be alarmed if the options you see below do not match the ones Slackware offers you. xwmconfig only offers choices that you installed. So for example, if you elected to skip the “KDE” disk set, KDE will not be offered.
Select your window manager   Root password he last configuration step is setting a root password. The root user is the “super user” on Slackware and all other UNIX-like operating systems. Think of root as the Administrator user. root knows all, sees all, and can do all, so setting a strong root password is just common sense.
Set the root password   Additional settings and reboot At this point Slackware is installed. If you need to do additional operations before rebooting, select the appropriate options in the following steps:
Remove installation media   Reboot?   Remove the Slackware installation disk, and if you performed all the steps correctly, your computer will boot into your new Slackware linux system. If something went wrong, you probably skipped the LILO configuration step or made an error there somehow.
Or be prepared to do your stuff in an screen like this before rebooting ☺
Reboot?   ]]></content:encoded>
      </item>
    
  </channel>
</rss>
