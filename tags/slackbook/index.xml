<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <docs>https://blogs.law.harvard.edu/tech/rss</docs>
    <title>Slackbook on Slackware</title>
    <link>/web/tags/slackbook/</link>
    <description>Recent content in Slackbook on Slackware</description>
    <image>
      <title>Slackbook on Slackware</title>
      <link>/web/tags/slackbook/</link>
      <url>/web/img/penguins.jpg</url>
    </image>
    <ttl>1440</ttl>
    <generator>Hugo 0.53</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 04 Aug 2018 08:01:21 +0000</lastBuildDate>
    
      <atom:link href="/web/tags/slackbook/index.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>Disk usage</title>
        <link>/web/posts/diskusage/</link>
        <pubDate>Sat, 04 Aug 2018 08:01:21 +0000</pubDate>
        <guid>/web/posts/diskusage/</guid>
        <description>In this post we will explore how to free disk space without reinstalling the system, and will present some scripts to help in the process.
</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[In this post we will explore how to free disk space without reinstalling the system, and will present some scripts to help in the process.
Introduction After some time using your system, installing new software and trying out settings, it&amp;rsquo;s inevitable to find that the disk usage is growing.
It could be a daunting process to free disk space, and most people will reinstall the systems again, adding to the new installation the experience got with the old one.
It&amp;rsquo;s common to think the in the new system, this problem will go away because you&amp;rsquo;ve learned a lot, and the system space will remain low, while only your data will increase. But on my experience, most people install again the operating system to clean it out.
A new installed Slackware, using the recommended installation process, installs aournd 10GB of software in your computer. But poking around and trying out software, can get you to 40GB in no time.
Our strategy to clean up the system will be:
 check the filesystem to see where is used the space check temporary files check installed packages and see how much space the use check files which do not belong to any package  Useful tools There are multiple tools to get information about filesystem usage, for example:
 xdiskusage   xdiskusage analisys of /     ncdu  ncdu showing / disk usage statistics   But sometimes we need to understand the problem to be able to use those tools correctly. Also if you make our own tools we will be able to automate certain tasks.
Filesystem usage The du utility, which stands for disk usage, can give you the size of a file or a folder.
With no arguments du will print the size of all files and folders from the current folder. And with the options -s and -h will summarize and print information of the current folder converting the size from Kb to the biggest unite possible (Mb, Gb, etc.)
gdiazlo@darkstar:~$ du -sh 9.4G . gdiazlo@darkstar:~$  It also accepts a parameter to show which folder is the starting point to calculate sizes:
gdiazlo@darkstar:~$ du -sh $HOME 9.4G . gdiazlo@darkstar:~$  So knowing where is the space going, it might tempt us to do
gdiazlo@darkstar:~$ du -sh /* but be aware: du will try to calculate the size of all mounted filesystems, including CD-ROMs, network shares, and synthetic filesystems like /proc. That will slow the process or even show errors.
A solution found in superuser.com site works well on a system with multiple mounted filesystems.
root@darkstar:~# for a in /*; do mountpoint -q -- &amp;#34;$a&amp;#34; || du -s -h -x &amp;#34;$a&amp;#34;; done 13M /bin 35M /boot 31M /etc 9.4G /home 559M /lib 27M /lib64 16K /lost&#43;found 64K /media 56K /mnt 212M /opt 1.9G /root 24M /sbin 4.0K /srv 4.9G /tmp 16G /usr 4.9G /var root@darkstar:~#  We can see in the list the top 5 space users:
 /usr uses 16G of space /home uses 9.5G of space /var uses 4.9G of space /tmp uses 4.9G of space /root uses 1.9G of space  All that combined is 37.2G of space.
The space used in /usr and /var should correspond to files from the operating system: installed software, packages, logs, databases, and together they account for 20.9G of space.
The space used in /tmp should be disposable as it only serves the purpose to contain ephemeral information.
And the /rootand/home` contain personal files from the administrator and the users of the computer.
With this information we state a different strategy to each case:
 system files: check packages and files that do not belong to any installed package temporary files: delete them if possible administrator and user files: check the downloads and temporary files, delete on your discretion  Identify system files We read about package managemt in Slackware to devise an strategy to:
 calculate the space used by installed packages identify orphan files (not related to any package) and their disk usage  Disk usage by installed packages We analize the space each packae uses throught its metadata files stored in /var/log/packages.
To show the packages ordered by its uncompressed size in ascending order:
#!/bin/bash  for p in `ls -1 /var/log/packages`; do head -n 3 /var/log/packages/$p | awk &amp;#39; /PACKAGE NAME:/ { name=$3 } /UNCOMPRESSED PACKAGE SIZE:/ { size=$4 } END{ print size, &amp;#34; &amp;#34; , name }&amp;#39; done | numfmt --from=si | sort -n -k 1 | numfmt --to=si The script is not very fast, but produce good results:
root@darkstar:~# ./pkgsize-meta | tail -n 10 168M emacs-26.1-x86_64-1 176M seamonkey-2.49.4-x86_64-1 220M kernel-modules-4.14.60-x86_64-1 285M mariadb-10.3.8-x86_64-1 297M kernel-firmware-20180730_7b5835f-noarch-1 335M qt5-5.11.1-x86_64-1alien 428M texlive-2018.180630-x86_64-2 529M rust-1.28.0-x86_64-1 718M llvm-6.0.1-x86_64-1 800M kernel-source-4.14.60-noarch-1 root@darkstar:~# Another example is calculate the size of all packages toghether:
root@darkstar:~# ./pkgsize-meta | numfmt --from=si | awk &amp;#39;{print $1}&amp;#39; | paste -sd&#43; | bc | numfmt --to=si 13G root@darkstar:~#  An installed file can grow over time, and this script will not take that into account. We can look in the disk ourselves instead of using the size provided by the package&amp;rsquo;s metadata file:
#!/bin/bash  PKGS=&amp;#34;/var/log/packages&amp;#34; LOGFILE=$(mktemp /tmp/pkgsize.XXXXXX) packages=$(ls -1 ${PKGS}/$1) total=0 for p in ${packages[@]}; do files=($(cat $p | sed &amp;#39;1,/FILE LIST/d&amp;#39; | sed &amp;#39;s/^/\//g&amp;#39; | grep -v &amp;#34;\/$&amp;#34; )) pkgsize=$( for i in $(seq 0 200 ${#files[@]}); do echo $(stat --printf=&amp;#34;%s &amp;#34; ${files[@]:$i:200} 2&amp;gt;$LOGFILE) | sed &amp;#39;s/ /\n/g&amp;#39; done | paste -sd&#43; | bc ) echo $pkgsize $p | numfmt --to=si total=$(( total &#43; pkgsize )) done echo $total | numfmt --to=si 
root@darkstar:~# ./pkgsize kernel-source-* 784M /var/log/packages/kernel-source-4.14.60-noarch-1 784M In the examples, the kernel package reported to use 800M in the metadata file and 784M using stat agains all the files and adding the result.
With this information we may decide to delete the packages we don&amp;rsquo;t use.
Identify orphan files An orphan file does not correspond to any installed package. This could mean is software or data generated during the system use. Maybe we installed or tried to install applications that polluted our system with files and didn&amp;rsquo;t user the package management tools.
To decrease the number of orphan files, use Appimage or flatpak to install software which do not have a package for Slackware. Also consider making your own packages, it is easy and allows you to control all the files on your system.
We can devise a script to find all orphan files and list them along with their size in Kb. Be aware this script is slow and requires a considerable amount of RAM (around 400M on our case). See the contribution below for a better approach.
#!/bin/bash  LOGFILE=$(mktemp /tmp/pkgorphan.XXXXXX) files=() TMP=$(mktemp -d /tmp/orphan.XXXXXX) cd $TMP for p in `ls -1 /var/log/packages`; do cat /var/log/packages/$p |sed -e &amp;#39;1,/FILE LIST/d&amp;#39; | sed &amp;#39;s/^/\//g&amp;#39; | sed &amp;#39;s/\/$//g&amp;#39; done | sort -u &amp;gt; meta for i in usr bin sbin lib lib64 opt srv var etc root; do find /$i -type f done | sort -u &amp;gt; disk awk &amp;#39;NR==FNR { A[$1] ; next } !($1 in A) { print $1 }&amp;#39; meta disk &amp;gt; orphans files=($(cat orphans)) for i in $(seq 0 200 ${#files[@]}); do ls -d -s -1 ${files[@]:$i:200} 2&amp;gt;$LOGFILE done &amp;gt; orphans-size A brave soul on #irc contributed another way to look for orphans, with better performance:
#!bin/bash # This needs bash for arrays # # Author: Jakub Jankowski &amp;lt;shasta@slackware.pl&amp;gt; # ONLY_FSTYPES_RGXP=&amp;#39;^(btrfs|ext[234]|xfs|jfs)$&amp;#39; SKIP_PATHS=( &amp;#39;/root/*&amp;#39; &amp;#39;/home/*&amp;#39; &amp;#39;/mnt/*&amp;#39; &amp;#39;/var/run/*&amp;#39; &amp;#39;/var/tmp/*&amp;#39; &amp;#39;/var/spool/*&amp;#39; &amp;#39;/var/log/pkgtools/*&amp;#39; &amp;#39;/var/lib/pkgtools/*&amp;#39; &amp;#39;/var/lib/sbopkg/*&amp;#39; &amp;#39;/var/cache/lxc/*&amp;#39; &amp;#39;/usr/src/linux*&amp;#39; &amp;#39;/tmp/*&amp;#39; ) # create temporary files FROM_PKGS=$(mktemp) FROM_FS=$(mktemp) set -e # list all files/dirs brought by packages; # we are also stripping .new suffix as that&amp;#39;s how config # files come in, but they are later mv&amp;#39;d &amp;#34;foo.new&amp;#34; &amp;#34;foo&amp;#34; for pkg in /var/log/packages/*; do sed -e &amp;#39;1,/^FILE LIST:/d; /^\.\/$/d; /^install\//d; s,^,/,; s,\.new$,,; s,/$,,&amp;#39; &amp;#34;$pkg&amp;#34; done &amp;gt; &amp;#34;$FROM_PKGS&amp;#34; # find all files/directories on filesystem, but only if fs type is one of $ONLY_FSTYPES_RGXP; # on&amp;#39;t descend to other filesystems (-xdev), and ignore paths from $SKIP_PATHS declare -a EXCL=( ) for p in &amp;#34;${SKIP_PATHS[@]}&amp;#34;; do if [ ${#EXCL[@]} -eq 0 ]; then EXCL=( &amp;#34;${EXCL[@]}&amp;#34; &amp;#39;-path&amp;#39; &amp;#34;$p&amp;#34; &amp;#39;-prune&amp;#39; ) else EXCL=( &amp;#34;${EXCL[@]}&amp;#34; &amp;#39;-o&amp;#39; &amp;#39;-path&amp;#39; &amp;#34;$p&amp;#34; &amp;#39;-prune&amp;#39; ) fi done [ ${#EXCL[@]} -gt 0 ] &amp;amp;&amp;amp; EXCL=( &amp;#34;${EXCL[@]}&amp;#34; &amp;#39;-o&amp;#39; &amp;#39;-print&amp;#39; ) find $(awk -v fstypes=&amp;#34;$ONLY_FSTYPES_RGXP&amp;#34; &amp;#39;$3 ~ fstypes {print $2}&amp;#39; /proc/mounts) \  -xdev &amp;#34;${EXCL[@]}&amp;#34; 2&amp;gt;/dev/null &amp;gt; &amp;#34;$FROM_FS&amp;#34; # output needs to be sorted for join(1) to work LC_ALL=C sort -u -o &amp;#34;$FROM_PKGS&amp;#34; &amp;#34;$FROM_PKGS&amp;#34; LC_ALL=C sort -u -o &amp;#34;$FROM_FS&amp;#34; &amp;#34;$FROM_FS&amp;#34; # see which paths in $FROM_FS are not in $FROM_PKGS LC_ALL=C join -a 2 -v 2 &amp;#34;$FROM_PKGS&amp;#34; &amp;#34;$FROM_FS&amp;#34; # clean up other two temp files rm &amp;#34;$FROM_FS&amp;#34; &amp;#34;$FROM_PKGS&amp;#34; The script will give us a list of orphans. We can compute the size they use on disk using that list.
We can further explore the results the script generated in the file orphans-size:
 show the top-ten orphan files by its disk usage:  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | sort -k 1 -n -u | tail -n 10 | sed &amp;#39;s/ \//K \//&amp;#39; | numfmt --from=si --to=si 96M /var/lib/flatpak/repo/objects/05/91c08407fbaa7dccc4cbc541865d27d4714b14d51417dc658841e3cd96d489.commitmeta 105M /usr/local/cuda-9.2/lib64/libcufft_static.a 115M /usr/local/cuda-9.2/nsightee_plugins/com.nvidia.cuda.repo-1.0.0-SNAPSHOT.zip 117M /usr/local/cuda-9.2/lib64/libcusolver.so.9.2.148 124M /var/lib/flatpak/app/com.spotify.Client/x86_64/stable/0591c08407fbaa7dccc4cbc541865d27d4714b14d51417dc658841e3cd96d489/files/extra/share/spotify/libcef.so 132M /var/tmp/elvis1.ses 177M /usr/local/cuda-9.2/lib64/libnvgraph_static.a 252M /var/lib/flatpak/repo/objects/69/74b95360b298f4cfe1be4025689ea20e918b689a5110984b3ffe7d339faf45.file 252M /var/lib/flatpak/repo/objects/df/45dafc31028c33ba2b26b08342dfe4044937e54eb9a3305c1cea28b5e9dfb5.file 330M /var/cache/sbopkg/qt-everywhere-opensource-src-5.7.1.tar.xz root@darkstar:/tmp/orphan.xvA0L1#   summary the size of an specific folder  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | grep &amp;#34;/usr/local/cuda-9.2*&amp;#34; | awk &amp;#39;{print $1}&amp;#39; | sort -n -k 1 | paste -sd&#43; | bc | sed &amp;#39;s/$/K/&amp;#39; | numfmt --from=si --to=si 2.9G root@darkstar:/tmp/orphan.xvA0L1#   summary to the second level directory hierarchy  root@darkstar:/tmp/orphan.xvA0L1# cat orphans-size | cut -d &amp;#39;/&amp;#39; -f 1,2,3 | sort -n -k 1 -u | awk &amp;#39;{size[$2]&#43;=$1}END{for (s in size){print size[s],&amp;#34; &amp;#34;, s}}&amp;#39; | sort -k1 -n | sed &amp;#39;s/ /K /&amp;#39; | numfmt --from=si --to=si | tail -n 10 88M /root/.cache 115M /usr/share 125M /root/NVIDIA_CUDA-9.2_Samples 138M /var/tmp 165M /opt/calibre 188M /usr/lib64 515M /var/cache 1.2G /root/latest 2.4G /var/lib 2.5G /usr/local root@darkstar:/tmp/orphan.xvA0L1# After all this work, isn&amp;rsquo;t there an application to work this out without arcane shell commands?
Delete unwanted files After the analysis we&amp;rsquo;ve identified where the disk space is and what kind of files use them:
 /usr/local contains 2.5G of unaccounted space, used by cuda, plan9ports and go installations /var/lib contains 2.4G of unaccounted space, used by pacakge tools like SlackBuilds or Flatpak. /root cotains 1.2G of unaccounted space, used by cuda and other scripts  Also we identified packages we don&amp;rsquo;t use which use a lot of disk space like MariaDB, Rust, or TeX.
With that in mind we can free up a couple of GB easily without breaking anything on the system, just deleting the folders with rm.
]]></content:encoded>
      </item>
    
      <item>
        <title>The Slackware Book</title>
        <link>/web/posts/slackbook/</link>
        <pubDate>Sat, 28 Jul 2018 08:01:21 +0000</pubDate>
        <guid>/web/posts/slackbook/</guid>
        <description>The Slackware Book can be read online in its original form at: slackbook.
I&amp;rsquo;ll reproduce here the introduction paragraphs. Please consider to collaborate with the Slackware documentation project in it&amp;rsquo;s web site
</description>
        <category domain="/categories/documentation">Documentation</category>
        <content:encoded><![CDATA[The Slackware Book can be read online in its original form at: slackbook.
I&amp;rsquo;ll reproduce here the introduction paragraphs. Please consider to collaborate with the Slackware documentation project in it&amp;rsquo;s web site
Why Use Slackware? Slackware has a long tradition of excellence. Started in 1992 and first released in 1993, Slackware is the oldest surviving commercial Linux distribution. Slackware&amp;rsquo;s focus on making a clean, simple Linux distribution that is as UNIX-like as possible makes it a natural choice for those people who really want to learn about Linux and other UNIX-like operating systems. In a 2012 interview, Slackware founder and benevolent dictator for life, Patrick Volkerding, put it thusly.
&amp;ldquo;I try not to let things get juggled around simply for the sake of making them different. People who come back to Slackware after a time tend to be pleasantly surprised that they don&amp;rsquo;t need to relearn how to do everything. This has given us quite a loyal following, for which I am grateful.&amp;rdquo;
Slackware&amp;rsquo;s simplicity makes it ideal for those users who want to create their own custom systems. Of course, Slackware is great in its own right as a desktop, workstation, or server as well.
Differences Compared to Other Linux Distributions There are a great number of differences between Slackware and other mainstream distributions such as Red Hat, Debian, and Ubuntu. Perhaps the greatest difference is the lack of &amp;ldquo;hand-holding&amp;rdquo; that Slackware will do for the administrator. Many of those other distributions ship with custom graphical configuration tools for all manner of services. In many cases, these configuration tools are the preferred method of setting up applications on these systems and will overwrite any changes you make to the configuration files via other means. These tools often make it easy (or at least possible) for a rookie with no in-depth understanding of his system to setup basic services; however, they also make it difficult to do anything too out of the ordinary. In contrast, Slackware expects you, the system administrator, to do these tasks on your own. Slackware provides no general purpose setup tools beyond those included with the source code published by upstream developers. This means there is often a somewhat steeper learning curve associated with Slackware, even for those users familiar with other Linux distributions, but also makes it much easier to do whatever you want with your operating system.
Also, you may hear users of other distributions say that Slackware has no package management system. This is completely and obviously false. Slackware has always had package management (see Chapter 17, Package Management for more information). What it does not have is automatic dependency resolution - Slackware&amp;rsquo;s package tools trade dependency management for simplicity, ease-of-use, and reliability.
Licensing Each piece of Slackware (this is true of all Linux distributions) is developed by different people (or teams of people), and each group has their own ideas about what it means to be &amp;ldquo;free&amp;rdquo;. Because of this, there are literally dozens and dozens of different licenses granting you different permissions regarding their use or distribution. Fortunately dealing with free software licenses isn&amp;rsquo;t as difficult as it may first appear. Most things are licensed with either the Gnu General Public License or the BSD license. Sometimes you&amp;rsquo;ll encounter a piece of software with a different license, but in almost all cases they are remarkably similar to either the GPL or the BSD license.
Probably the most popular license in use within the Free Software community is the GNU General Public License. The GPL was created by the Free Software Foundation, which actively works to create and distribute software that guarantees the freedoms which they believe are basic rights. In fact, this is the very group that coined the term &amp;ldquo;Free Software.&amp;rdquo; The GPL imposes no restrictions on the use of software. In fact, you don&amp;rsquo;t even have to accept the terms of the license in order to use the software, but you are not allowed to redistribute the software or any changes to it without abiding by the terms of the license agreement. A large number of software projects shipped with Slackware, from the Linux kernel itself to the Samba project, are released under the terms of the GPL.
Another very common license is the BSD license, which is arguably &amp;ldquo;more free&amp;rdquo; than the GPL because it imposes virtually no restrictions on derivative works. The BSD license simply requires that the copyright remain intact along with a simple disclaimer. Many of the utilities specific to Slackware are licensed with a BSD-style license, and this is the preferred license for many smaller projects and tools.
]]></content:encoded>
      </item>
    
  </channel>
</rss>
